import React, { useState, useEffect, useRef, useCallback } from 'react';
// Load Three.js library from CDN for single-file operation
const THREE = window.THREE = require('three');

// --- Configuration ---
const VISUAL_CONFIG = {
    GRID_SIZE: 10,
    SPACING: 3,
    CUBE_BASE_SIZE: 0.5,
};

// Define the styles and the logic for their appearance
const PRESET_STYLES = {
    'Neon Glitch': {
        color: 0x00ffff, // Cyan/Neon
        movementFactor: 0.8,
        scaleFactor: 2.0,
        rotationSpeed: 0.01,
        waveType: 'rapid', // Rapid, jumpy movement
    },
    'Liquid Flow': {
        color: 0xff00ff, // Magenta/Flow
        movementFactor: 0.4,
        scaleFactor: 1.5,
        rotationSpeed: 0.002,
        waveType: 'smooth', // Smooth sine wave movement
    },
    'Geometric Wave': {
        color: 0x00ff88, // Green/Geometric
        movementFactor: 0.6,
        scaleFactor: 2.5,
        rotationSpeed: 0.008,
        waveType: 'ripple', // Circular ripple effect
    },
    'Energy Particle': {
        color: 0xffff00, // Yellow/Energy
        movementFactor: 1.0,
        scaleFactor: 0.8, // Smaller size, particle feel
        rotationSpeed: 0.02,
        waveType: 'dense', // High movement and noise
    },
};

// --- Mock Audio Data Generator (Simulates music frequency/volume data) ---
const useMockAudioData = () => {
    const [mockData, setMockData] = useState(new Array(VISUAL_CONFIG.GRID_SIZE * VISUAL_CONFIG.GRID_SIZE).fill(0));
    const timeRef = useRef(0);

    useEffect(() => {
        const updateData = () => {
            timeRef.current += 0.05;
            const newData = [];
            for (let i = 0; i < VISUAL_CONFIG.GRID_SIZE * VISUAL_CONFIG.GRID_SIZE; i++) {
                // Simulate volume fluctuation and slight variation based on index
                const sinValue = Math.sin(timeRef.current + i * 0.2);
                const noise = Math.random() * 0.1;
                // Keep data between 0 and 1
                newData[i] = Math.max(0, (0.5 + 0.5 * sinValue) + noise);
            }
            setMockData(newData);
        };

        const interval = setInterval(updateData, 50); // Update 20 times per second

        return () => clearInterval(interval);
    }, []);

    return mockData;
};

// --- Main Application Component ---
const App = () => {
    // State for the currently selected visual style
    const [currentStyle, setCurrentStyle] = useState('Neon Glitch');
    const [intensity, setIntensity] = useState(0.5); // 0 to 1
    const [speed, setSpeed] = useState(0.5); // 0 to 1

    const canvasRef = useRef(null);
    const sceneRef = useRef(null);
    const cameraRef = useRef(null);
    const rendererRef = useRef(null);
    const meshesRef = useRef([]);
    const frameIdRef = useRef(null);
    const styleConfig = PRESET_STYLES[currentStyle];
    const mockAudioData = useMockAudioData();

    // 1. Initialize Scene (runs once on mount)
    useEffect(() => {
        const width = canvasRef.current.clientWidth;
        const height = canvasRef.current.clientHeight;

        // Scene
        const scene = new THREE.Scene();
        sceneRef.current = scene;
        scene.background = new THREE.Color(0x0a0a20); // Dark blue background

        // Camera
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 30;
        cameraRef.current = camera;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasRef.current });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        rendererRef.current = renderer;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Geometries
        const geometry = new THREE.BoxGeometry(VISUAL_CONFIG.CUBE_BASE_SIZE, VISUAL_CONFIG.CUBE_BASE_SIZE, VISUAL_CONFIG.CUBE_BASE_SIZE);
        meshesRef.current = [];
        const halfGrid = VISUAL_CONFIG.GRID_SIZE / 2;

        // Create a grid of cubes
        for (let x = 0; x < VISUAL_CONFIG.GRID_SIZE; x++) {
            for (let y = 0; y < VISUAL_CONFIG.GRID_SIZE; y++) {
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(styleConfig.color),
                    emissive: new THREE.Color(styleConfig.color).multiplyScalar(0.2),
                    shininess: 100,
                });
                const mesh = new THREE.Mesh(geometry, material);

                // Position the cube in the grid, centering it around (0, 0)
                mesh.position.x = (x - halfGrid + 0.5) * VISUAL_CONFIG.SPACING;
                mesh.position.y = (y - halfGrid + 0.5) * VISUAL_CONFIG.SPACING;
                mesh.position.z = 0; // Base Z position

                mesh.userData = { initialX: mesh.position.x, initialY: mesh.position.y, initialZ: mesh.position.z, index: x * VISUAL_CONFIG.GRID_SIZE + y };
                scene.add(mesh);
                meshesRef.current.push(mesh);
            }
        }

        // Handle window resize
        const handleResize = () => {
            if (canvasRef.current) {
                const newWidth = canvasRef.current.clientWidth;
                const newHeight = canvasRef.current.clientHeight;
                renderer.setSize(newWidth, newHeight);
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
            }
        };

        window.addEventListener('resize', handleResize);

        // Clean up
        return () => {
            window.removeEventListener('resize', handleResize);
            if (rendererRef.current) {
                rendererRef.current.dispose();
            }
            if (frameIdRef.current) {
                cancelAnimationFrame(frameIdRef.current);
            }
        };
    }, []); // Empty dependency array means this runs only once on mount

    // 2. Animation and Style Update Loop
    const animate = useCallback(() => {
        const meshes = meshesRef.current;
        const config = PRESET_STYLES[currentStyle];
        const time = Date.now() * 0.001 * speed * 2;
        const baseZ = cameraRef.current.position.z / 3; // Max Z displacement based on camera distance

        meshes.forEach((mesh) => {
            const { index, initialX, initialY } = mesh.userData;
            const audioVal = mockAudioData[index] || 0; // Use mock data to drive movement

            // --- Apply Style-Specific Logic ---

            let zMovement = 0;
            let scaleMultiplier = 1;
            let colorIntensity = 0;

            if (config.waveType === 'smooth') {
                // Liquid Flow: Smooth sine wave movement
                zMovement = Math.sin(time * 0.5 + initialX * 0.2 + initialY * 0.2) * baseZ * audioVal * intensity * config.movementFactor;
                scaleMultiplier = 1 + audioVal * config.scaleFactor * intensity;
                colorIntensity = audioVal * 0.5;
            } else if (config.waveType === 'ripple') {
                // Geometric Wave: Circular ripple/distance effect
                const distance = Math.sqrt(initialX * initialX + initialY * initialY);
                zMovement = Math.cos(time + distance * 0.5) * baseZ * audioVal * intensity * config.movementFactor;
                scaleMultiplier = 1 + audioVal * config.scaleFactor * intensity;
                colorIntensity = audioVal * 0.8;
            } else if (config.waveType === 'rapid') {
                // Neon Glitch: Jumpy, glitchy movement
                zMovement = Math.round(audioVal * intensity * config.movementFactor * baseZ / 2) * 2; // Quantized movement
                scaleMultiplier = 1 + (audioVal > 0.8 ? config.scaleFactor : 0) * intensity; // Scale only on high volume
                colorIntensity = audioVal * 1.0;
            } else if (config.waveType === 'dense') {
                // Energy Particle: Fast rotation and smaller scale change
                zMovement = (Math.random() - 0.5) * audioVal * baseZ * intensity * config.movementFactor * 2;
                scaleMultiplier = 1 + audioVal * config.scaleFactor * intensity;
                mesh.rotation.x += config.rotationSpeed * (audioVal + 0.1) * 10;
                mesh.rotation.y += config.rotationSpeed * (audioVal + 0.1) * 10;
                colorIntensity = audioVal * 0.3;
            }

            // Apply movement and scale
            mesh.position.z = zMovement;
            mesh.scale.setScalar(VISUAL_CONFIG.CUBE_BASE_SIZE * scaleMultiplier);
            
            // Apply constant rotation for style, if not overridden above
            if (config.waveType !== 'dense') {
                mesh.rotation.x += config.rotationSpeed * speed;
                mesh.rotation.y += config.rotationSpeed * speed;
            }
            
            // Update Color (using style color and audio value for intensity)
            const baseColor = new THREE.Color(config.color);
            const intensityColor = baseColor.clone().multiplyScalar(1 + colorIntensity);
            mesh.material.color.set(baseColor);
            mesh.material.emissive.set(intensityColor).multiplyScalar(0.2);
        });

        rendererRef.current.render(sceneRef.current, cameraRef.current);
        frameIdRef.current = requestAnimationFrame(animate);
    }, [currentStyle, mockAudioData, intensity, speed]); // Re-create animate function if dependencies change

    // 3. Start/Stop Animation and Update Materials
    useEffect(() => {
        // Stop any previous animation loop
        if (frameIdRef.current) {
            cancelAnimationFrame(frameIdRef.current);
        }
        
        // Update all cube materials to reflect the new style color
        meshesRef.current.forEach(mesh => {
            const config = PRESET_STYLES[currentStyle];
            const newColor = new THREE.Color(config.color);
            if (mesh.material) {
                mesh.material.color.set(newColor);
                mesh.material.emissive.set(newColor).multiplyScalar(0.2);
            }
        });

        // Start the new animation loop
        if (rendererRef.current) {
            animate();
        }

        // Cleanup: Stop animation when component unmounts
        return () => {
            if (frameIdRef.current) {
                cancelAnimationFrame(frameIdRef.current);
            }
        };
    }, [animate, currentStyle]); // Rerun when animate function or style changes

    // Tailwind UI Components
    const Button = ({ name, active }) => (
        <button
            onClick={() => setCurrentStyle(name)}
            className={`
                w-full p-3 rounded-xl transition duration-200 text-sm font-medium tracking-wide
                ${active
                    ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-500/50 transform scale-[1.02]'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white'
                }
            `}
        >
            {name}
        </button>
    );

    const Slider = ({ label, value, onChange, min, max, step }) => (
        <div className="mb-6">
            <label className="text-gray-300 text-sm font-semibold block mb-2">
                {label}
            </label>
            <input
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer range-lg transition duration-150"
                style={{
                    '--tw-ring-color': 'rgb(79 70 229)', // indigo-600
                    '--tw-ring-opacity': '1',
                    '--tw-ring-offset-width': '0px',
                    '--tw-shadow': 'var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow-colored)',
                    '--tw-shadow-colored': '0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color)',
                    '--tw-shadow-color': 'rgb(79 70 229)',
                }}
            />
        </div>
    );

    return (
        <div className="flex h-screen w-screen text-white bg-gray-900 font-inter">
            {/* Left Control Panel */}
            <div className="w-1/4 min-w-[300px] p-6 bg-gray-800 overflow-y-auto shadow-2xl z-10">
                <h1 className="text-2xl font-bold mb-8 text-indigo-400">éŸ³æ¨‚è¦–è¦ºåŒ–æ§åˆ¶å°</h1>

                {/* 1. Music Input (Mock) */}
                <section className="mb-8 p-4 bg-gray-700/50 rounded-xl">
                    <h2 className="text-lg font-semibold mb-3 text-gray-200">ğŸµ è¼¸å…¥éŸ³æ¨‚ (æ¨¡æ“¬)</h2>
                    <div className="flex items-center justify-between p-3 bg-gray-700 rounded-lg">
                        <span className="text-sm text-gray-400">ä½¿ç”¨æ¨¡æ“¬éŸ³è¨Šè³‡æ–™é©…å‹•</span>
                        <div className="px-3 py-1 bg-green-600 text-white text-xs rounded-full">LIVE</div>
                    </div>
                </section>

                {/* 2. Style Selection */}
                <section className="mb-8 p-4 bg-gray-700/50 rounded-xl">
                    <h2 className="text-lg font-semibold mb-4 text-gray-200">âœ¨ é¸æ“‡é è¨­é¢¨æ ¼</h2>
                    <div className="grid grid-cols-2 gap-3">
                        {Object.keys(PRESET_STYLES).map(key => (
                            <Button
                                key={key}
                                name={key}
                                active={currentStyle === key}
                            />
                        ))}
                    </div>
                </section>

                {/* 3. Parameter Settings */}
                <section className="p-4 bg-gray-700/50 rounded-xl">
                    <h2 className="text-lg font-semibold mb-4 text-gray-200">âš™ï¸ åƒæ•¸å°æ‡‰è¨­å®š (å³æ™‚èª¿æ•´)</h2>
                    
                    {/* Beat/Rhythm (Size) -> Mocked by Intensity */}
                    <Slider
                        label={`ç¯€æ‹/éŸ»å¾‹ (Beat/Rhythm) -> å¹¾ä½•ä½ç§» (ç›®å‰: ${(intensity * 100).toFixed(0)}%)`}
                        min={0.1}
                        max={1.0}
                        step={0.01}
                        value={intensity}
                        onChange={setIntensity}
                    />
                    
                    {/* Animation Speed */}
                    <Slider
                        label={`å‹•ç•«é€Ÿåº¦ (Animation Speed) -> æ•´é«”æ™‚é–“æµå‹• (ç›®å‰: ${(speed * 100).toFixed(0)}%)`}
                        min={0.1}
                        max={1.0}
                        step={0.01}
                        value={speed}
                        onChange={setSpeed}
                    />

                    <p className="text-xs text-gray-400 mt-4">
                        æç¤º: é¢¨æ ¼è¨­å®šå·²ç¶“ä¿®å¾©ã€‚é»æ“Šä¸Šæ–¹æŒ‰éˆ•å³å¯åˆ‡æ›å®Œæ•´çš„è¦–è¦ºåŒ–æ•ˆæœã€‚
                    </p>
                </section>
            </div>

            {/* Right Visualizer Output */}
            <div className="flex-1 relative flex items-center justify-center">
                <canvas ref={canvasRef} className="w-full h-full block" />
                <div className="absolute bottom-4 right-4 bg-gray-800/80 p-3 rounded-xl text-xs text-indigo-400">
                    ç›®å‰é¢¨æ ¼: {currentStyle}
                </div>
            </div>
        </div>
    );
};

export default App;
