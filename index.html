<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…±æ„Ÿå·¥ä½œå®¤ - éŸ³æ¨‚è¦–è¦ºåŒ–ç”Ÿæˆå™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #canvas-3d {
            display: block;
            width: 100%;
            height: 100%;
        }
        #canvas-2d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #4B5563;
            border-radius: 4px;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #6366F1;
            border-radius: 50%;
            cursor: pointer;
        }
        .preset-btn.active {
            background: #6366F1 !important;
            border-color: #818CF8 !important;
        }
        .style-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen antialiased">

    <div id="app" class="flex h-screen overflow-hidden">

        <!-- å·¦å´æ§åˆ¶é¢æ¿ -->
        <div class="w-full lg:w-1/3 xl:w-1/4 p-6 flex flex-col space-y-4 bg-gray-800 border-r border-gray-700 overflow-y-auto">
            
            <header class="pb-4 border-b border-gray-700">
                <h1 class="text-2xl font-extrabold text-indigo-400">å…±æ„Ÿå·¥ä½œå®¤</h1>
                <p class="text-xs text-gray-400 mt-1">éŸ³æ¨‚ Ã— è—è¡“ Ã— è¦–è¦ºåŒ–</p>
            </header>

            <!-- éŸ³æ¨‚è¼¸å…¥å€ -->
            <div class="space-y-2">
                <h2 class="text-lg font-semibold text-gray-200">ğŸµ è¼¸å…¥éŸ³æ¨‚</h2>
                <input type="file" id="music-input" accept="audio/*" class="hidden" onchange="handleFileSelect(event)">
                <label for="music-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 transition text-white font-bold py-2 px-4 rounded-lg text-sm block text-center">
                    ğŸ“¤ ä¸Šå‚³éŸ³æ¨‚
                </label>
                <p id="file-name" class="text-xs text-gray-400 italic">æœªé¸æ“‡æª”æ¡ˆ</p>
                <audio id="audio-player"></audio>
            </div>

            <!-- åœ–ç‰‡ä¸Šå‚³å€ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-lg font-semibold text-gray-200">ğŸ–¼ï¸ ä¸Šå‚³åœ–ç‰‡</h2>
                <input type="file" id="image-input" accept="image/*" class="hidden" onchange="handleImageSelect(event)">
                <label for="image-input" class="cursor-pointer bg-purple-600 hover:bg-purple-700 transition text-white font-bold py-2 px-4 rounded-lg text-sm block text-center">
                    ğŸ¨ ä¸Šå‚³åœ–ç‰‡
                </label>
                <img id="preview-image" class="hidden rounded-lg max-h-24 mx-auto">
            </div>

            <!-- é è¨­é¢¨æ ¼ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-lg font-semibold text-gray-200">âœ¨ è¦–è¦ºé¢¨æ ¼ï¼ˆ12ç¨®ï¼‰</h2>
                <div class="style-grid text-xs">
                    <button class="preset-btn active bg-indigo-600 p-2 rounded-lg font-medium border-2 border-indigo-400" data-preset="neon">éœ“è™¹æ•…éšœ</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="liquid">æµå‹•æ¶²æ…‹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="geometric">å¹¾ä½•æ³¢ç´‹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="particle">èƒ½é‡ç²’å­</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="spectrum">é »è­œæŸ±ç‹€</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="ripple">æ¼£æ¼ªæ³¢å‹•</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="spiral">æ—‹è½‰èºæ—‹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="trail">å…‰è»Œè·¡</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="mandelbrot">åˆ†å½¢è—è¡“</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="plasma">é›»æ¼¿æ•ˆæ‡‰</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="tunnel">æ˜Ÿå…‰éš§é“</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="imagewave">åœ–ç‰‡æ³¢å‹•</button>
                </div>
            </div>

            <!-- åƒæ•¸æ§åˆ¶ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-lg font-semibold text-gray-200">âš™ï¸ åƒæ•¸</h2>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">ç¯€æ‹</label>
                    <input type="range" min="1" max="100" value="75" id="range-beat">
                </div>

                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">é¡è‰²</label>
                    <input type="range" min="1" max="100" value="45" id="range-frequency">
                </div>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">å¯†åº¦</label>
                    <input type="range" min="1" max="100" value="90" id="range-intensity">
                </div>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">é€Ÿåº¦</label>
                    <input type="range" min="1" max="100" value="60" id="range-speed">
                </div>
            </div>

            <!-- æŒ‰éˆ• -->
            <div class="pt-2 border-t border-gray-700">
                <button id="start-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg text-sm">
                    â–¶ï¸ é–‹å§‹ç”Ÿæˆ
                </button>
            </div>
        </div>

        <!-- å³å´è¦–è¦ºè¼¸å‡º -->
        <div class="flex-1 relative bg-black overflow-hidden">
            <h2 class="absolute top-4 left-4 z-10 text-lg font-bold text-white bg-black bg-opacity-50 px-3 py-1 rounded">
                ğŸ¨ è¦–è¦ºè¼¸å‡º
            </h2>
            <canvas id="canvas-3d"></canvas>
            <canvas id="canvas-2d"></canvas>
            
            <!-- æ’­æ”¾æ§åˆ¶ -->
            <div class="absolute bottom-0 w-full p-4 bg-gray-900 bg-opacity-70 flex justify-center items-center space-x-4">
                <button class="p-3 bg-gray-700 hover:bg-gray-600 rounded-full transition" id="btn-rewind">
                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                </button>
                <button id="play-pause-btn" class="p-4 bg-indigo-600 hover:bg-indigo-500 rounded-full transition">
                    <svg class="w-7 h-7 text-white" id="play-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                </button>
                <button class="p-3 bg-gray-700 hover:bg-gray-600 rounded-full transition" id="btn-forward">
                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // â•â•â• å…¨åŸŸè¨­å®š â•â•â•
        const canvas3D = document.getElementById('canvas-3d');
        const canvas2D = document.getElementById('canvas-2d');
        const ctx2D = canvas2D.getContext('2d');
        const audioPlayer = document.getElementById('audio-player');
        const fileNameDisplay = document.getElementById('file-name');
        const startBtn = document.getElementById('start-btn');
        const playIcon = document.getElementById('play-icon');
        const previewImage = document.getElementById('preview-image');
        
        let scene, camera, renderer;
        let audioContext, analyser, dataArray;
        let isPlaying = false;
        let currentPreset = 'neon';
        let uploadedImage = null;
        
        // â•â•â• äº‹ä»¶ç¶å®š â•â•â•
        document.getElementById('music-input').addEventListener('change', handleFileSelect);
        document.getElementById('image-input').addEventListener('change', handleImageSelect);
        document.getElementById('start-btn').addEventListener('click', togglePlayback);
        document.getElementById('play-pause-btn').addEventListener('click', togglePlayback);
        document.getElementById('btn-rewind').addEventListener('click', () => audioPlayer.currentTime -= 5);
        document.getElementById('btn-forward').addEventListener('click', () => audioPlayer.currentTime += 5);

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => switchPreset(e.target.dataset.preset));
        });

        // â•â•â• å‡½æ•¸ï¼šè™•ç†æª”æ¡ˆé¸æ“‡ â•â•â•
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                const file = files[0];
                fileNameDisplay.textContent = file.name;
                audioPlayer.src = URL.createObjectURL(file);
                setupAudioAnalysis();
                isPlaying = false;
                updateButtonState();
            }
        }

        function handleImageSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage = img;
                        previewImage.src = img.src;
                        previewImage.classList.remove('hidden');
                        
                        // ç«‹å³æ›´æ–°å ´æ™¯èƒŒæ™¯
                        if (styles[currentPreset].is3D) {
                            updateSceneWithImage();
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(files[0]);
            }
        }

        // â•â•â• å‡½æ•¸ï¼šéŸ³è¨Šè¨­å®š â•â•â•
        function setupAudioAnalysis() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                const source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        function togglePlayback() {
            if (!audioPlayer.src) {
                startBtn.textContent = "âŒ è«‹å…ˆä¸Šå‚³æª”æ¡ˆ";
                setTimeout(() => updateButtonState(), 1500);
                return;
            }

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
            } else {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioPlayer.play().catch(err => console.error(err));
                isPlaying = true;
            }
            updateButtonState();
        }

        function updateButtonState() {
            if (isPlaying) {
                startBtn.innerHTML = 'â¸ï¸ æš«åœ';
                startBtn.classList.remove('bg-green-600');
                startBtn.classList.add('bg-red-600');
                playIcon.innerHTML = '<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" fill="currentColor"/>';
            } else {
                startBtn.innerHTML = 'â–¶ï¸ é–‹å§‹ç”Ÿæˆ';
                startBtn.classList.remove('bg-red-600');
                startBtn.classList.add('bg-green-600');
                playIcon.innerHTML = '<path d="M8 5v14l11-7z" fill="currentColor"/>';
            }
        }

        // â•â•â• å‡½æ•¸ï¼šéŸ³è¨Šæ•¸æ“š â•â•â•
        function getAudioData() {
            if (!analyser || !isPlaying) {
                return { beat: 0, mid: 0, high: 0, intensity: 0, data: new Uint8Array(128) };
            }

            analyser.getByteFrequencyData(dataArray);
            let beat = 0, mid = 0, high = 0, intensity = 0;
            
            const lowEnd = Math.floor(dataArray.length * 0.15);
            const midEnd = Math.floor(dataArray.length * 0.4);
            
            for (let i = 0; i < lowEnd; i++) beat += dataArray[i];
            beat = beat / lowEnd / 255;

            for (let i = lowEnd; i < midEnd; i++) mid += dataArray[i];
            mid = mid / (midEnd - lowEnd) / 255;

            for (let i = midEnd; i < dataArray.length; i++) high += dataArray[i];
            high = high / (dataArray.length - midEnd) / 255;

            for (let i = 0; i < dataArray.length; i++) intensity += dataArray[i];
            intensity = intensity / dataArray.length / 255;

            return { beat, mid, high, intensity, data: dataArray };
        }

        // â•â•â• Three.js åˆå§‹åŒ– â•â•â•
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 100, 2000);

            camera = new THREE.PerspectiveCamera(75, canvas3D.clientWidth / canvas3D.clientHeight, 0.1, 1000);
            camera.position.z = 2;

            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true, alpha: true });
            renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight);
            renderer.setClearColor(0x0a0a0a, 1);

            // å¢å¼·å…‰ç·šè¨­ç½®
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00ffff, 1.5, 100);
            pointLight.position.set(0, 0, 3);
            scene.add(pointLight);

            window.addEventListener('resize', () => {
                const w = canvas3D.clientWidth;
                const h = canvas3D.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                canvas2D.width = w;
                canvas2D.height = h;
            });

            canvas2D.width = canvas3D.clientWidth;
            canvas2D.height = canvas3D.clientHeight;
        }

        // â•â•â• åœ–ç‰‡ç›¸é—œ â•â•â•
        function applyImageBackground() {
            if (!uploadedImage) return;
            
            // å‰µå»ºåœ–ç‰‡ç´‹ç†
            const canvas = document.createElement('canvas');
            canvas.width = uploadedImage.width;
            canvas.height = uploadedImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(uploadedImage, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // ä¿®æ”¹å ´æ™¯èƒŒæ™¯ç‚ºåœ–ç‰‡
        function updateSceneWithImage() {
            if (uploadedImage) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas3D.clientWidth;
                canvas.height = canvas3D.clientHeight;
                const ctx = canvas.getContext('2d');
                
                // è¨ˆç®—åœ–ç‰‡æ¯”ä¾‹
                const imgAspect = uploadedImage.width / uploadedImage.height;
                const canvasAspect = canvas.width / canvas.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgAspect > canvasAspect) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (canvas.height - drawHeight) / 2;
                }
                
                ctx.globalAlpha = 0.3;
                ctx.drawImage(uploadedImage, drawX, drawY, drawWidth, drawHeight);
                
                const texture = new THREE.CanvasTexture(canvas);
                scene.background = texture;
            }
        }
        const styles = {
            neon: { setup: setupNeon, update: updateNeon, is3D: true },
            liquid: { setup: setupLiquid, update: updateLiquid, is3D: true },
            geometric: { setup: setupGeometric, update: updateGeometric, is3D: true },
            particle: { setup: setupParticle, update: updateParticle, is3D: true },
            spectrum: { setup: setupSpectrum, update: updateSpectrum, is3D: true },
            ripple: { setup: setupRipple, update: updateRipple, is3D: true },
            spiral: { setup: setupSpiral, update: updateSpiral, is3D: true },
            trail: { setup: setupTrail, update: updateTrail, is3D: true },
            mandelbrot: { setup: () => {}, update: updateMandelbrot, is3D: false },
            plasma: { setup: () => {}, update: updatePlasma, is3D: false },
            tunnel: { setup: setupTunnel, update: updateTunnel, is3D: true },
            imagewave: { setup: () => {}, update: updateImageWave, is3D: false }
        };

        function switchPreset(preset) {
            currentPreset = preset;
            document.querySelectorAll('.preset-btn').forEach(b => {
                b.classList.remove('active', 'bg-indigo-600', 'border-indigo-400');
                b.classList.add('bg-gray-700', 'border-transparent');
            });
            event.target.classList.add('active', 'bg-indigo-600', 'border-indigo-400');
            
            const isCanvas3D = styles[preset].is3D;
            canvas3D.style.display = isCanvas3D ? 'block' : 'none';
            canvas2D.style.display = isCanvas3D ? 'none' : 'block';
            
            if (styles[preset].setup) {
                styles[preset].setup();
                // æ·»åŠ åœ–ç‰‡èƒŒæ™¯
                if (isCanvas3D) {
                    updateSceneWithImage();
                }
            }
        }

        // â•â•â• é¢¨æ ¼ï¼šéœ“è™¹ â•â•â•
        function setupNeon() {
            scene.clear();
            for (let i = 0; i < 8; i++) {
                const points = [];
                for (let x = -1; x <= 1; x += 0.05) {
                    points.push(new THREE.Vector3(x, Math.random() * 0.5, 0));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ 
                    color: new THREE.Color().setHSL(0.3 + i * 0.08, 1, 0.5),
                    linewidth: 3
                });
                const line = new THREE.Line(geo, mat);
                line.position.y = -1 + i * 0.3;
                line.userData.points = points;
                scene.add(line);
            }
        }

        function updateNeon(audioData) {
            const { beat, high, intensity } = audioData;
            scene.children.forEach((line, i) => {
                const hue = (0.3 + i * 0.08 + high * 0.5 + Date.now() / 8000) % 1;
                line.material.color.setHSL(hue, 1, 0.5 + intensity * 0.2);
                line.material.linewidth = 2 + beat * 5;
                
                if (Math.random() > 0.85) {
                    line.position.x = (Math.random() - 0.5) * 0.4 * beat;
                    line.position.z = (Math.random() - 0.5) * 0.2;
                }
            });
        }

        // â•â•â• é¢¨æ ¼ï¼šæ¶²æ…‹ â•â•â•
        let liquidMesh;
        function setupLiquid() {
            scene.clear();
            const geo = new THREE.IcosahedronGeometry(1, 6);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x0088ff,
                emissiveIntensity: 0.8,
                metalness: 0.3,
                roughness: 0.4,
                envMapIntensity: 1
            });
            liquidMesh = new THREE.Mesh(geo, mat);
            scene.add(liquidMesh);
        }

        function updateLiquid(audioData) {
            if (liquidMesh) {
                liquidMesh.rotation.x += audioData.beat * 0.05;
                liquidMesh.rotation.y += audioData.mid * 0.05;
                liquidMesh.rotation.z += audioData.high * 0.02;
                liquidMesh.scale.setScalar(1.2 + audioData.beat * 0.5);
                
                const hue = (audioData.mid + Date.now() / 3000) % 1;
                liquidMesh.material.color.setHSL(hue, 1, 0.5);
                liquidMesh.material.emissive.setHSL(hue, 1, 0.4);
                liquidMesh.material.emissiveIntensity = 0.5 + audioData.intensity * 0.8;
            }
        }

        // â•â•â• é¢¨æ ¼ï¼šå¹¾ä½• â•â•â•
        function setupGeometric() {
            scene.clear();
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.OctahedronGeometry(0.3, 3);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 12, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 12, 1, 0.3),
                    emissiveIntensity: 0.8,
                    metalness: 0.2,
                    roughness: 0.3
                });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = i / 12 * Math.PI * 2;
                mesh.position.x = Math.cos(angle) * 1.5;
                mesh.position.y = Math.sin(angle) * 1.5;
                mesh.userData.angle = angle;
                mesh.userData.baseRadius = 1.5;
                mesh.userData.hueOffset = i / 12;
                scene.add(mesh);
            }
        }

        function updateGeometric(audioData) {
            scene.children.forEach((mesh, i) => {
                const radius = mesh.userData.baseRadius + audioData.beat * 0.8;
                mesh.position.x = Math.cos(mesh.userData.angle) * radius;
                mesh.position.y = Math.sin(mesh.userData.angle) * radius;
                mesh.rotation.x += audioData.high * 0.08;
                mesh.rotation.y += audioData.high * 0.08;
                mesh.rotation.z += audioData.beat * 0.03;
                mesh.scale.setScalar(0.8 + audioData.intensity * 0.5);
                
                const hue = (mesh.userData.hueOffset + audioData.high * 0.5 + Date.now() / 4000) % 1;
                mesh.material.color.setHSL(hue, 1, 0.6);
                mesh.material.emissive.setHSL(hue, 1, 0.35);
                mesh.material.emissiveIntensity = 0.6 + audioData.beat * 0.6;
            });
        }

        // â•â•â• é¢¨æ ¼ï¼šç²’å­ â•â•â•
        let particleSystem;
        function setupParticle() {
            scene.clear();
            const count = 1500;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                pos[i * 3] = (Math.random() - 0.5) * 6;
                pos[i * 3 + 1] = (Math.random() - 0.5) * 6;
                pos[i * 3 + 2] = (Math.random() - 0.5) * 6;
                
                const hue = Math.random();
                const rgb = hslToRgb(hue, 1, 0.6);
                colors[i * 3] = rgb[0] / 255;
                colors[i * 3 + 1] = rgb[1] / 255;
                colors[i * 3 + 2] = rgb[2] / 255;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ 
                size: 0.04, 
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true
            });
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
        }

        function updateParticle(audioData) {
            if (particleSystem) {
                const pos = particleSystem.geometry.attributes.position.array;
                const colors = particleSystem.geometry.attributes.color.array;
                
                for (let i = 0; i < pos.length; i += 3) {
                    pos[i] += (Math.random() - 0.5) * audioData.intensity * 0.2;
                    pos[i + 1] += (Math.random() - 0.5) * audioData.beat * 0.15;
                    pos[i + 2] += (Math.random() - 0.5) * audioData.mid * 0.15;
                    
                    // é‚Šç•Œæª¢æŸ¥
                    if (Math.abs(pos[i]) > 3) pos[i] = (Math.random() - 0.5) * 6;
                    if (Math.abs(pos[i + 1]) > 3) pos[i + 1] = (Math.random() - 0.5) * 6;
                    if (Math.abs(pos[i + 2]) > 3) pos[i + 2] = (Math.random() - 0.5) * 6;
                    
                    // æ›´æ–°é¡è‰²
                    const hue = (i / pos.length + audioData.high + Date.now() / 3000) % 1;
                    const rgb = hslToRgb(hue, 1, 0.6);
                    colors[i] = rgb[0] / 255;
                    colors[i + 1] = rgb[1] / 255;
                    colors[i + 2] = rgb[2] / 255;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.color.needsUpdate = true;
                particleSystem.rotation.x += audioData.beat * 0.01;
                particleSystem.rotation.y += audioData.beat * 0.01;
            }
        }

        // â•â•â• é¢¨æ ¼ï¼šé »è­œ â•â•â•
        function setupSpectrum() {
            scene.clear();
            for (let i = 0; i < 32; i++) {
                const geo = new THREE.BoxGeometry(0.08, 0.5, 0.08);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 32, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 32, 1, 0.35),
                    emissiveIntensity: 0.9,
                    metalness: 0.1,
                    roughness: 0.2
                });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = i / 32 * Math.PI * 2;
                mesh.position.x = Math.cos(angle) * 1.5;
                mesh.position.z = Math.sin(angle) * 1.5;
                mesh.userData.spectrumIndex = i;
                mesh.userData.hueOffset = i / 32;
                scene.add(mesh);
            }
        }

        function updateSpectrum(audioData) {
            scene.children.forEach((mesh) => {
                const idx = Math.floor(mesh.userData.spectrumIndex * audioData.data.length / 32);
                const val = audioData.data[idx] / 255;
                mesh.scale.y = 0.5 + val * 1.5;
                
                const hue = (mesh.userData.hueOffset + Date.now() / 5000) % 1;
                mesh.material.color.setHSL(hue, 1, 0.5 + val * 0.3);
                mesh.material.emissive.setHSL(hue, 1, 0.3 + val * 0.4);
                mesh.material.emissiveIntensity = 0.6 + val * 0.6;
            });
        }

        // â•â•â• é¢¨æ ¼ï¼šæ¼£æ¼ª â•â•â•
        let rippleMesh;
        function setupRipple() {
            scene.clear();
            const geo = new THREE.PlaneGeometry(4, 4, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.6,
                wireframe: true,
                metalness: 0.3,
                roughness: 0.5
            });
            rippleMesh = new THREE.Mesh(geo, mat);
            rippleMesh.userData.originalPos = new Float32Array(geo.attributes.position.array);
            scene.add(rippleMesh);
        }

        function updateRipple(audioData) {
            if (rippleMesh) {
                const pos = rippleMesh.geometry.attributes.position.array;
                const orig = rippleMesh.userData.originalPos;
                const time = Date.now() * 0.001;
                
                for (let i = 2; i < pos.length; i += 3) {
                    const x = orig[i - 2];
                    const y = orig[i - 1];
                    const dist = Math.sqrt(x * x + y * y);
                    pos[i] = Math.sin(dist * 10 - time * 5) * (0.3 + audioData.beat * 0.8) + 
                             Math.cos(time * 3 + dist) * audioData.mid * 0.2;
                }
                rippleMesh.geometry.attributes.position.needsUpdate = true;
                rippleMesh.geometry.computeVertexNormals();
                
                const hue = (audioData.beat * 0.5 + Date.now() / 4000) % 1;
                rippleMesh.material.color.setHSL(hue, 1, 0.5);
                rippleMesh.material.emissive.setHSL(hue, 1, 0.4);
                rippleMesh.material.emissiveIntensity = 0.5 + audioData.intensity * 0.5;
            }
        }

        // â•â•â• é¢¨æ ¼ï¼šèºæ—‹ â•â•â•
        function setupSpiral() {
            scene.clear();
            for (let layer = 0; layer < 5; layer++) {
                const count = 20 + layer * 5;
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.15, 8, 8);
                    const hue = (layer / 5 + i / count) % 1;
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(hue, 1, 0.6),
                        emissive: new THREE.Color().setHSL(hue, 1, 0.35),
                        emissiveIntensity: 0.8,
                        metalness: 0.2,
                        roughness: 0.3
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = i / count * Math.PI * 2;
                    const radius = 0.5 + layer * 0.4;
                    mesh.position.x = Math.cos(angle) * radius;
                    mesh.position.y = Math.sin(angle) * radius;
                    mesh.position.z = (layer - 2) * 0.5;
                    mesh.userData.layer = layer;
                    mesh.userData.index = i;
                    mesh.userData.count = count;
                    mesh.userData.hueOffset = hue;
                    scene.add(mesh);
                }
            }
        }

        function updateSpiral(audioData) {
            scene.children.forEach((mesh) => {
                mesh.rotation.x += audioData.high * 0.05;
                mesh.rotation.y += audioData.beat * 0.05;
                mesh.rotation.z += audioData.mid * 0.02;
                mesh.scale.setScalar(1 + audioData.beat * 0.3);
                
                const hue = (mesh.userData.hueOffset + Date.now() / 3000 + audioData.intensity * 0.5) % 1;
                mesh.material.color.setHSL(hue, 1, 0.6);
                mesh.material.emissive.setHSL(hue, 1, 0.35);
                mesh.material.emissiveIntensity = 0.6 + audioData.beat * 0.6;
            });
        }

        // â•â•â• é¢¨æ ¼ï¼šè»Œè·¡ â•â•â•
        function setupTrail() {
            scene.clear();
            for (let i = 0; i < 5; i++) {
                const curve = new THREE.LineCurve3(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0));
                const geo = new THREE.TubeGeometry(curve, 20, 0.1, 8);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 5, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 5, 1, 0.35),
                    emissiveIntensity: 0.9,
                    metalness: 0.4,
                    roughness: 0.2
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.z = i / 5 * Math.PI * 2;
                mesh.userData.index = i;
                scene.add(mesh);
            }
        }

        function updateTrail(audioData) {
            scene.children.forEach((mesh, i) => {
                mesh.rotation.z += audioData.beat * 0.05;
                mesh.rotation.x += audioData.mid * 0.02;
                mesh.rotation.y += audioData.high * 0.02;
                mesh.scale.setScalar(1 + audioData.beat * 0.4);
                
                const hue = (i / 5 + Date.now() / 3000 + audioData.beat * 0.3) % 1;
                mesh.material.color.setHSL(hue, 1, 0.6);
                mesh.material.emissive.setHSL(hue, 1, 0.35);
                mesh.material.emissiveIntensity = 0.7 + audioData.intensity * 0.5;
            });
        }

        // â•â•â• é¢¨æ ¼ï¼šéš§é“ â•â•â•
        function setupTunnel() {
            scene.clear();
            for (let layer = 0; layer < 10; layer++) {
                const count = 16;
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.1, 8, 8);
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(layer / 10 + i / count, 1, 0.6),
                        emissive: new THREE.Color().setHSL(layer / 10 + i / count, 1, 0.35),
                        emissiveIntensity: 0.9,
                        metalness: 0.2,
                        roughness: 0.3
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = i / count * Math.PI * 2;
                    const radius = 0.3 + layer * 0.25;
                    mesh.position.x = Math.cos(angle) * radius;
                    mesh.position.y = Math.sin(angle) * radius;
                    mesh.position.z = -3 + layer * 0.7;
                    mesh.userData.layer = layer;
                    mesh.userData.baseAngle = angle;
                    scene.add(mesh);
                }
            }
        }

        function updateTunnel(audioData) {
            scene.children.forEach((mesh) => {
                mesh.position.z += 0.08 + audioData.beat * 0.05;
                if (mesh.position.z > 1) {
                    mesh.position.z = -3 + mesh.userData.layer * 0.7;
                }
                
                mesh.scale.setScalar(1 + audioData.beat * 0.4 + audioData.intensity * 0.2);
                mesh.rotation.x += audioData.beat * 0.02;
                mesh.rotation.y += audioData.beat * 0.02;
                
                const hue = (mesh.userData.layer / 10 + Date.now() / 4000 + audioData.high * 0.3) % 1;
                mesh.material.color.setHSL(hue, 1, 0.6);
                mesh.material.emissive.setHSL(hue, 1, 0.35);
                mesh.material.emissiveIntensity = 0.7 + audioData.intensity * 0.5;
            });
        }

        // â•â•â• 2D é¢¨æ ¼ï¼šMandelbrot â•â•â•
        function updateMandelbrot(audioData) {
            ctx2D.fillStyle = '#0a0a0a';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = 0.5 + audioData.intensity * 2;
            const centerX = 0.5 + audioData.high * 0.3;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const cr = (x / w - 0.5) / scale + centerX;
                    const ci = (y / h - 0.5) / scale + 0.5;

                    let real = cr, imag = ci;
                    let iter = 0;
                    for (let i = 0; i < 50; i++) {
                        const r2 = real * real, i2 = imag * imag;
                        if (r2 + i2 > 4) break;
                        const temp = r2 - i2 + cr;
                        imag = 2 * real * imag + ci;
                        real = temp;
                        iter++;
                    }
                    const hue = (iter / 50 + Date.now() / 5000) % 1;
                    const rgb = hslToRgb(hue, 1, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // â•â•â• 2D é¢¨æ ¼ï¼šé›»æ¼¿ â•â•â•
        function updatePlasma(audioData) {
            ctx2D.fillStyle = '#0a0a0a';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const time = Date.now() * 0.001;
            const w = canvas2D.width;
            const h = canvas2D.height;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const v = Math.sin((x + time * 100) * 0.01) +
                             Math.sin((y + time * 50) * 0.01) +
                             Math.sin(Math.sqrt(x * x + y * y) * 0.01 + time * 50) * audioData.beat;

                    const hue = (v * 0.3 + audioData.high + Date.now() / 5000) % 1;
                    const rgb = hslToRgb(hue, 1, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // â•â•â• 2D é¢¨æ ¼ï¼šåœ–ç‰‡æ³¢å‹• â•â•â•
        function updateImageWave(audioData) {
            ctx2D.fillStyle = 'rgba(10, 10, 10, 0.2)';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            if (!uploadedImage) {
                ctx2D.fillStyle = '#666';
                ctx2D.font = '18px Arial';
                ctx2D.textAlign = 'center';
                ctx2D.fillText('è«‹ä¸Šå‚³åœ–ç‰‡ä»¥ä½¿ç”¨æ­¤æ•ˆæœ', canvas2D.width / 2, canvas2D.height / 2);
                return;
            }

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = Math.min(w / uploadedImage.width, h / uploadedImage.height) * 0.85;
            const x = (w - uploadedImage.width * scale) / 2;
            const y = (h - uploadedImage.height * scale) / 2;

            ctx2D.globalAlpha = 0.9 + audioData.intensity * 0.1;
            ctx2D.drawImage(uploadedImage, x, y, uploadedImage.width * scale, uploadedImage.height * scale);
            ctx2D.globalAlpha = 1;

            // å¤šå±¤æ³¢ç´‹æ•ˆæœ
            const waveCount = 2 + Math.floor(audioData.intensity * 4);
            for (let waveIdx = 0; waveIdx < waveCount; waveIdx++) {
                const waveOffset = waveIdx * 0.4;
                ctx2D.strokeStyle = `hsl(${(audioData.beat * 360 + audioData.high * 180 + waveIdx * 60) % 360}, 100%, ${60 + audioData.intensity * 20}%)`;
                ctx2D.lineWidth = 1 + audioData.beat * 3;
                ctx2D.globalAlpha = 0.7 - waveIdx * 0.15;
                
                ctx2D.beginPath();
                for (let px = -50; px <= w + 50; px += 5) {
                    const py = h / 2 + Math.sin((px * 0.008 + Date.now() * 0.0008 + waveOffset) * 8) * audioData.beat * 120 + 
                               Math.sin(waveOffset * 5 + Date.now() * 0.001) * audioData.intensity * 60;
                    px === -50 ? ctx2D.moveTo(px, py) : ctx2D.lineTo(px, py);
                }
                ctx2D.stroke();
            }

            // é¡è‰²ç–ŠåŠ 
            ctx2D.globalAlpha = 0.15 + audioData.beat * 0.2;
            ctx2D.fillStyle = `hsl(${(audioData.high * 360) % 360}, 100%, 50%)`;
            ctx2D.fillRect(0, 0, w, h);

            ctx2D.globalAlpha = 1;
        }

        // â•â•â• è‰²å½©è½‰æ› â•â•â•
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // â•â•â• ä¸»å‹•ç•«å¾ªç’° â•â•â•
        function animate() {
            requestAnimationFrame(animate);

            const audioData = getAudioData();
            const style = styles[currentPreset];

            if (style.is3D) {
                style.update(audioData);
                renderer.render(scene, camera);
            } else {
                style.update(audioData);
            }
        }

        // â•â•â• åˆå§‹åŒ– â•â•â•
        window.addEventListener('load', () => {
            initThree();
            setupNeon();
            updateSceneWithImage();
            animate();
            updateButtonState();
        });
    </script>
</body>
</html>
