
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…±æ„Ÿå·¥ä½œå®¤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: #ffffff; color: #1a1a1a; }
        
        #canvas-3d {
            display: block;
            width: 100%;
            height: 100%;
            background: white;
        }
        #canvas-2d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            background: white;
        }
        
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #d0d0d0;
            border-radius: 4px;
            width: 100%;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .preset-btn.active {
            background: #1DB954 !important;
            border-color: #1ed760 !important;
        }
        
        .style-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .left-panel {
            background: linear-gradient(135deg, #f8f8f8 0%, #ffffff 100%);
            border-right: 1px solid #e0e0e0;
        }
        
        .bg-section {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
        }
    </style>
</head>
<body class="h-screen overflow-hidden">
    <div class="flex h-screen">
        <!-- å·¦å´æ§åˆ¶é¢æ¿ -->
        <div class="w-80 left-panel overflow-y-auto p-4 space-y-4 border-r border-gray-300">
            <h1 class="text-2xl font-bold text-green-600">ğŸ¨ å…±æ„Ÿå·¥ä½œå®¤</h1>
            <p class="text-xs text-gray-600">éŸ³æ¨‚ Ã— è—è¡“ Ã— è¦–è¦ºåŒ–</p>

            <!-- éŸ³æ¨‚ä¾†æº -->
            <div class="space-y-2">
                <h2 class="text-sm font-semibold text-gray-800">ğŸµ éŸ³æ¨‚ä¾†æº</h2>
                
                <div class="space-y-2 bg-section p-3 rounded-lg">
                    <label class="text-xs font-medium text-blue-600">ğŸ“¤ ä¸Šå‚³éŸ³æ¨‚æª”æ¡ˆ</label>
                    <input type="file" id="music-input" accept="audio/*" class="hidden">
                    <label for="music-input" class="cursor-pointer block text-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg text-xs transition">
                        ğŸ“¤ é¸æ“‡éŸ³æ¨‚ (MP3/WAV)
                    </label>
                    <p id="music-name" class="text-xs text-gray-600">æœªé¸æ“‡</p>
                    <input type="range" id="volume-slider" min="0" max="100" value="70" class="w-full">
                    <p class="text-xs text-gray-600">éŸ³é‡: <span id="volume-value">70</span>%</p>
                    <audio id="audio-player" crossorigin="anonymous"></audio>
                </div>
            </div>

            <!-- æ’­æ”¾æ§åˆ¶ -->
            <div class="space-y-2 bg-section p-3 rounded-lg">
                <label class="text-xs font-medium text-gray-800">â¯ï¸ æ’­æ”¾æ§åˆ¶</label>
                <button id="play-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-xs transition">
                    â–¶ï¸ é¸æ“‡éŸ³æ¨‚é–‹å§‹
                </button>
            </div>

            <!-- åœ–ç‰‡ & æ—‹è½‰ -->
            <div class="space-y-2">
                <h2 class="text-sm font-semibold text-gray-800">ğŸ–¼ï¸ èƒŒæ™¯åœ–ç‰‡ & æ—‹è½‰</h2>
                
                <input type="file" id="image-input" accept="image/*" class="hidden">
                <label for="image-input" class="cursor-pointer block text-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg text-xs transition">
                    ğŸ–¼ï¸ ä¸Šå‚³åœ–ç‰‡
                </label>
                <p id="image-name" class="text-xs text-gray-600">æœªé¸æ“‡</p>

                <!-- 3D æ—‹è½‰æ§åˆ¶ -->
                <div class="space-y-1 bg-section p-3 rounded-lg">
                    <label class="text-xs font-medium text-purple-600">æ—‹è½‰è»¸</label>
                    <select id="rotation-axis" class="w-full px-2 py-1 bg-white border border-gray-300 text-gray-800 rounded text-xs">
                        <option value="none">âŒ ä¸æ—‹è½‰</option>
                        <option value="x">â†‘â†“ ç¹Xè»¸æ—‹è½‰</option>
                        <option value="y" selected>â†â†’ ç¹Yè»¸æ—‹è½‰ï¼ˆè¿·å› è²“è²“ï¼‰</option>
                        <option value="z">â†» ç¹Zè»¸æ—‹è½‰</option>
                    </select>
                    
                    <label class="text-xs font-medium text-purple-600 mt-2 block">æ—‹è½‰é€Ÿåº¦</label>
                    <input type="range" id="rotation-speed-slider" min="0.1" max="5" step="0.1" value="1" class="w-full">
                    <p class="text-xs text-gray-600">é€Ÿåº¦: <span id="rotation-speed-value">1.0</span>x</p>
                    
                    <label class="text-xs block mt-2 text-gray-700">
                        <input type="checkbox" id="auto-rotate-checkbox" checked class="mr-2">
                        æ’­æ”¾æ™‚è‡ªå‹•æ—‹è½‰
                    </label>
                </div>
            </div>

            <!-- åƒæ•¸èª¿æ•´ -->
            <div class="space-y-2">
                <h2 class="text-sm font-semibold text-gray-800">âš™ï¸ åƒæ•¸èª¿æ•´</h2>
                <p class="text-xs text-gray-600">èª¿æ•´é€™äº›åƒæ•¸æœƒæ”¹è®Šè¦–è¦ºæ•ˆæœå¼·åº¦å’Œé€Ÿåº¦</p>

                <div class="control-group bg-section p-3 rounded-lg space-y-3">
                    <div>
                        <label class="text-xs font-medium text-green-600 block">ğŸ¯ ç¯€æ‹æ•æ„Ÿåº¦: <span id="beat-value">75</span>%</label>
                        <input type="range" id="range-beat" min="1" max="100" value="75" class="w-full">
                        <p class="text-xs text-gray-600 mt-1">è¶Šé«˜ = è¦–è¦ºåŒ–åæ‡‰è¶Šå¼·</p>
                    </div>

                    <div>
                        <label class="text-xs font-medium text-green-600 block">ğŸŒˆ é¡è‰²é£½å’Œåº¦: <span id="frequency-value">45</span>%</label>
                        <input type="range" id="range-frequency" min="1" max="100" value="45" class="w-full">
                        <p class="text-xs text-gray-600 mt-1">è¶Šé«˜ = é¡è‰²è¶Šé®®è±”</p>
                    </div>

                    <div>
                        <label class="text-xs font-medium text-green-600 block">ğŸ’¥ æ•ˆæœå¼·åº¦: <span id="intensity-value">90</span>%</label>
                        <input type="range" id="range-intensity" min="1" max="100" value="90" class="w-full">
                        <p class="text-xs text-gray-600 mt-1">è¶Šé«˜ = æ•ˆæœè¶Šæ˜é¡¯</p>
                    </div>

                    <div>
                        <label class="text-xs font-medium text-green-600 block">âš¡ å‹•ç•«é€Ÿåº¦: <span id="speed-value">60</span>%</label>
                        <input type="range" id="range-speed" min="1" max="100" value="60" class="w-full">
                        <p class="text-xs text-gray-600 mt-1">è¶Šé«˜ = å‹•ä½œè¶Šå¿«</p>
                    </div>
                </div>
            </div>

            <!-- è¦–è¦ºé¢¨æ ¼é¸æ“‡ -->
            <div class="space-y-2">
                <h2 class="text-sm font-semibold text-gray-800">ğŸ¨ è¦–è¦ºé¢¨æ ¼ (12ç¨®)</h2>
                <div class="style-grid">
                    <button class="preset-btn active bg-green-600 border-2 border-green-400 p-2 rounded text-xs font-bold transition text-white" data-preset="neon">ğŸ”¦ éœ“è™¹æ•…éšœ</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="liquid">ğŸ’§ æµå‹•æ¶²æ…‹</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="geometric">ğŸ”· å¹¾ä½•æ³¢ç´‹</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="particle">âœ¨ èƒ½é‡ç²’å­</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="spectrum">ğŸ“Š é »è­œæŸ±ç‹€</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="ripple">ã€°ï¸ æ¼£æ¼ªæ³¢å‹•</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="spiral">ğŸŒ€ æ—‹è½‰èºæ—‹</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="trail">ğŸŒŒ å…‰è»Œè·¡</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="tunnel">ğŸŒ  æ˜Ÿå…‰éš§é“</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="mandelbrot">ğŸ­ åˆ†å½¢è—è¡“</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="plasma">âš¡ é›»æ¼¿æ•ˆæ‡‰</button>
                    <button class="preset-btn bg-gray-300 border-2 border-transparent p-2 rounded text-xs font-bold transition text-gray-800 hover:border-gray-400" data-preset="imagewave">ğŸŒŠ åœ–ç‰‡æ³¢å‹•</button>
                </div>
            </div>
        </div>

        <!-- å³å´è¦–è¦ºè¼¸å‡º -->
        <div class="flex-1 relative bg-white overflow-hidden">
            <h2 class="absolute top-4 left-4 z-10 text-lg font-bold text-gray-800 bg-white bg-opacity-80 px-3 py-1 rounded">
                ğŸ¨ è¦–è¦ºè¼¸å‡º
            </h2>
            <canvas id="canvas-3d"></canvas>
            <canvas id="canvas-2d"></canvas>
        </div>
    </div>

    <script>
        // â•â•â• DOM å…ƒç´  â•â•â•
        const canvas3D = document.getElementById('canvas-3d');
        const canvas2D = document.getElementById('canvas-2d');
        const ctx2D = canvas2D.getContext('2d');
        const audioPlayer = document.getElementById('audio-player');

        // â•â•â• Three.js è®Šæ•¸ â•â•â•
        let scene, camera, renderer;
        let audioContext, analyser, dataArray;
        let isPlaying = false;
        let currentPreset = 'neon';
        let uploadedImage = null;

        // â•â•â• 3D åœ–ç‰‡å°è±¡ â•â•â•
        let imageMesh = null;
        let rotationAxis = 'y';
        let rotationSpeed = 1;
        let enable3DRotation = true;

        // â•â•â• éŸ³é‡æ§åˆ¶ â•â•â•
        document.getElementById('volume-slider').addEventListener('input', (e) => {
            const vol = parseFloat(e.target.value) / 100;
            audioPlayer.volume = vol;
            document.getElementById('volume-value').textContent = e.target.value;
        });

        // â•â•â• æ—‹è½‰æ§åˆ¶ â•â•â•
        document.getElementById('rotation-axis').addEventListener('change', (e) => {
            rotationAxis = e.target.value;
        });
        document.getElementById('rotation-speed-slider').addEventListener('input', (e) => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotation-speed-value').textContent = rotationSpeed.toFixed(1);
        });
        document.getElementById('auto-rotate-checkbox').addEventListener('change', (e) => {
            enable3DRotation = e.target.checked;
        });

        // â•â•â• åƒæ•¸å€¼é¡¯ç¤º â•â•â•
        document.getElementById('range-beat').addEventListener('input', (e) => {
            document.getElementById('beat-value').textContent = e.target.value;
        });
        document.getElementById('range-frequency').addEventListener('input', (e) => {
            document.getElementById('frequency-value').textContent = e.target.value;
        });
        document.getElementById('range-intensity').addEventListener('input', (e) => {
            document.getElementById('intensity-value').textContent = e.target.value;
        });
        document.getElementById('range-speed').addEventListener('input', (e) => {
            document.getElementById('speed-value').textContent = e.target.value;
        });

        // â•â•â• éŸ³é »åˆ†æ â•â•â•
        function setupAudioAnalysis() {
            if (audioContext) return;

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            const source = audioContext.createMediaElementAudioSource(audioPlayer);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        // â•â•â• ç²å–éŸ³é »æ•¸æ“š â•â•â•
        function getAudioData() {
            const beatControl = parseFloat(document.getElementById('range-beat').value) / 100;
            const frequencyControl = parseFloat(document.getElementById('range-frequency').value) / 100;
            const intensityControl = parseFloat(document.getElementById('range-intensity').value) / 100;
            const speedControl = parseFloat(document.getElementById('range-speed').value) / 100;

            if (!analyser || !isPlaying) {
                const time = Date.now() / 1000;
                return { 
                    beat: (0.3 + Math.sin(time * 2) * 0.2) * beatControl, 
                    mid: (0.25 + Math.sin(time * 1.5) * 0.15) * beatControl, 
                    high: (0.4 + Math.cos(time * 1.8) * 0.2) * frequencyControl, 
                    intensity: (0.5 + Math.sin(time * 2.5) * 0.3) * intensityControl, 
                    data: new Uint8Array(128).fill(180),
                    beatControl, frequencyControl, intensityControl, speedControl
                };
            }

            analyser.getByteFrequencyData(dataArray);
            let beat = 0, mid = 0, high = 0, intensity = 0;
            
            const lowEnd = Math.floor(dataArray.length * 0.15);
            const midEnd = Math.floor(dataArray.length * 0.4);
            
            for (let i = 0; i < lowEnd; i++) beat += dataArray[i];
            beat = (beat / lowEnd / 255) * beatControl;

            for (let i = lowEnd; i < midEnd; i++) mid += dataArray[i];
            mid = (mid / (midEnd - lowEnd) / 255) * beatControl;

            for (let i = midEnd; i < dataArray.length; i++) high += dataArray[i];
            high = (high / (dataArray.length - midEnd) / 255) * frequencyControl;

            for (let i = 0; i < dataArray.length; i++) intensity += dataArray[i];
            intensity = (intensity / dataArray.length / 255) * intensityControl;

            return { beat, mid, high, intensity, data: dataArray, beatControl, frequencyControl, intensityControl, speedControl };
        }

        // â•â•â• Three.js åˆå§‹åŒ– â•â•â•
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, canvas3D.clientWidth / canvas3D.clientHeight, 0.1, 1000);
            camera.position.z = 2;

            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true, alpha: true });
            renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x1DB954, 1.5, 100);
            pointLight.position.set(0, 0, 3);
            scene.add(pointLight);

            window.addEventListener('resize', () => {
                const w = canvas3D.clientWidth;
                const h = canvas3D.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                canvas2D.width = w;
                canvas2D.height = h;
            });

            canvas2D.width = canvas3D.clientWidth;
            canvas2D.height = canvas3D.clientHeight;
        }

        // â•â•â• å ´æ™¯æ¸…ç†å‡½æ•¸ â•â•â•
        function clearSceneObjects() {
            const objectsToRemove = [];
            scene.children.forEach(obj => {
                if (obj instanceof THREE.Line || 
                    (obj instanceof THREE.Mesh && obj !== imageMesh) || 
                    obj instanceof THREE.Points) {
                    objectsToRemove.push(obj);
                }
            });
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
        }

        // â•â•â• æ·»åŠ èƒŒæ™¯åœ–ç‰‡åˆ°å ´æ™¯ â•â•â•
        function addImageToScene() {
            // ç§»é™¤èˆŠåœ–ç‰‡
            if (imageMesh) {
                scene.remove(imageMesh);
                if (imageMesh.geometry) imageMesh.geometry.dispose();
                if (imageMesh.material) imageMesh.material.dispose();
            }

            if (!uploadedImage) return;

            const canvas = document.createElement('canvas');
            canvas.width = uploadedImage.width;
            canvas.height = uploadedImage.height;
            const ctxImg = canvas.getContext('2d');
            ctxImg.drawImage(uploadedImage, 0, 0);

            const texture = new THREE.CanvasTexture(canvas);
            const aspect = uploadedImage.width / uploadedImage.height;
            
            const geo = new THREE.PlaneGeometry(aspect * 1.5, 1.5);
            const mat = new THREE.MeshBasicMaterial({ map: texture });
            imageMesh = new THREE.Mesh(geo, mat);
            imageMesh.position.z = -0.5;
            scene.add(imageMesh);
        }

        // â•â•â• æ‰€æœ‰è¦–è¦ºé¢¨æ ¼ â•â•â•
        function setupNeon() {
            clearSceneObjects();
            for (let i = 0; i < 8; i++) {
                const points = [];
                for (let x = -1; x <= 1; x += 0.05) {
                    points.push(new THREE.Vector3(x, Math.random() * 0.5, 0));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ color: 0x1DB954, linewidth: 2 });
                const line = new THREE.Line(geo, mat);
                line.position.y = -1 + i * 0.3;
                scene.add(line);
            }
            addImageToScene();
        }

        function updateNeon(audioData) {
            const speedMult = audioData.speedControl || 0.6;
            scene.children.forEach((line, i) => {
                if (line instanceof THREE.Line) {
                    const baseHue = (audioData.high * 0.5 + i * 0.1 + Date.now() / 10000) % 1;
                    const saturation = audioData.frequencyControl;
                    const lightness = 0.3 + audioData.intensityControl * 0.4;
                    
                    line.material.color.setHSL(baseHue, saturation, lightness);
                    
                    if (Math.random() > 0.8 * (1 - audioData.beat * audioData.beatControl)) {
                        line.position.x = (Math.random() - 0.5) * audioData.beatControl * 0.5;
                        line.position.y = (Math.random() - 0.5) * audioData.beatControl * 0.3;
                    }
                    line.material.linewidth = 1 + audioData.intensityControl * 3;
                }
            });
        }

        // æ¶²æ…‹
        let liquidMesh = null;
        function setupLiquid() {
            clearSceneObjects();
            const geo = new THREE.IcosahedronGeometry(0.8, 4);
            const mat = new THREE.MeshStandardMaterial({ color: 0x1DB954, emissive: 0x1DB954, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
            liquidMesh = new THREE.Mesh(geo, mat);
            scene.add(liquidMesh);
            addImageToScene();
        }

        function updateLiquid(audioData) {
            if (liquidMesh) {
                const speedMult = audioData.speedControl || 0.6;
                liquidMesh.rotation.x += audioData.beat * 0.05 * speedMult * 2;
                liquidMesh.rotation.y += audioData.mid * 0.05 * speedMult * 2;
                liquidMesh.scale.setScalar(1.2 + audioData.beatControl * 0.3 + audioData.intensityControl * 0.8);
                const hue = (audioData.mid + Date.now() / 3000) % 1;
                liquidMesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5 + audioData.intensityControl * 0.3);
                liquidMesh.material.emissiveIntensity = 0.3 + audioData.intensityControl * 0.7;
            }
        }

        // å¹¾ä½•
        function setupGeometric() {
            clearSceneObjects();
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.OctahedronGeometry(0.4, 0);
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 12, 1, 0.6), emissive: new THREE.Color().setHSL(i / 12, 1, 0.3), emissiveIntensity: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = (i / 12) * Math.PI * 2;
                const radius = 1.2;
                mesh.position.x = Math.cos(angle) * radius;
                mesh.position.y = Math.sin(angle) * radius;
                mesh.userData = { baseRadius: radius, angle: angle, hueOffset: i / 12 };
                scene.add(mesh);
            }
            addImageToScene();
        }

        function updateGeometric(audioData) {
            const speedMult = audioData.speedControl || 0.6;
            scene.children.forEach((mesh, i) => {
                if (mesh instanceof THREE.Mesh && mesh !== imageMesh) {
                    const radius = mesh.userData.baseRadius + audioData.beatControl * audioData.intensityControl * 1.2;
                    mesh.position.x = Math.cos(mesh.userData.angle) * radius;
                    mesh.position.y = Math.sin(mesh.userData.angle) * radius;
                    mesh.rotation.x += audioData.high * 0.08 * speedMult * 2;
                    mesh.rotation.y += audioData.high * 0.08 * speedMult * 2;
                    const hue = (mesh.userData.hueOffset + audioData.high * audioData.frequencyControl * 0.8 + Date.now() / 4000) % 1;
                    mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                    mesh.material.emissiveIntensity = 0.3 + audioData.intensityControl * 0.7;
                }
            });
        }

        // ç²’å­
        let particleSystem = null;
        function setupParticle() {
            clearSceneObjects();
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(1500 * 3);
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] = (Math.random() - 0.5) * 6;
                positions[i + 1] = (Math.random() - 0.5) * 6;
                positions[i + 2] = (Math.random() - 0.5) * 6;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ size: 0.05, color: 0x1DB954, sizeAttenuation: true });
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
            addImageToScene();
        }

        function updateParticle(audioData) {
            if (particleSystem) {
                const speedMult = audioData.speedControl || 0.6;
                const pos = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < pos.length; i += 3) {
                    pos[i] += (Math.random() - 0.5) * audioData.intensityControl * 0.4;
                    pos[i + 1] += (Math.random() - 0.5) * audioData.beat * 0.2;
                    if (Math.abs(pos[i]) > 3) pos[i] = (Math.random() - 0.5) * 6;
                    if (Math.abs(pos[i + 1]) > 3) pos[i + 1] = (Math.random() - 0.5) * 6;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.x += audioData.beat * 0.01 * speedMult * 2;
                particleSystem.rotation.y += audioData.beat * 0.01 * speedMult * 2;
            }
        }

        // é »è­œ
        function setupSpectrum() {
            clearSceneObjects();
            for (let i = 0; i < 32; i++) {
                const geo = new THREE.BoxGeometry(0.05, 1, 0.05);
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 32, 1, 0.6), emissive: new THREE.Color().setHSL(i / 32, 1, 0.3), emissiveIntensity: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = -0.8 + (i / 32) * 1.6;
                mesh.userData = { spectrumIndex: i, hueOffset: i / 32 };
                scene.add(mesh);
            }
            addImageToScene();
        }

        function updateSpectrum(audioData) {
            scene.children.forEach((mesh) => {
                if (mesh instanceof THREE.Mesh && mesh !== imageMesh) {
                    const idx = Math.floor(mesh.userData.spectrumIndex * audioData.data.length / 32);
                    const val = audioData.data[idx] / 255;
                    mesh.scale.y = 0.3 + val * audioData.intensityControl * 2;
                    const hue = (mesh.userData.hueOffset + Date.now() / 5000) % 1;
                    mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5 + val * 0.3);
                    mesh.material.emissiveIntensity = 0.2 + val * audioData.intensityControl * 0.8;
                }
            });
        }

        // æ¼£æ¼ª
        let rippleMesh = null;
        function setupRipple() {
            clearSceneObjects();
            const geo = new THREE.PlaneGeometry(2, 2, 50, 50);
            const mat = new THREE.MeshStandardMaterial({ color: 0x1DB954, emissive: 0x0a5a2a, emissiveIntensity: 0.5 });
            rippleMesh = new THREE.Mesh(geo, mat);
            scene.add(rippleMesh);
            const orig = rippleMesh.geometry.attributes.position.array.slice();
            rippleMesh.userData.originalPos = orig;
            addImageToScene();
        }

        function updateRipple(audioData) {
            if (rippleMesh) {
                const speedMult = audioData.speedControl || 0.6;
                const pos = rippleMesh.geometry.attributes.position.array;
                const orig = rippleMesh.userData.originalPos;
                const time = Date.now() * 0.001 * speedMult * 2;
                for (let i = 2; i < pos.length; i += 3) {
                    const x = orig[i - 2];
                    const y = orig[i - 1];
                    const dist = Math.sqrt(x * x + y * y);
                    pos[i] = Math.sin(dist * 10 - time * 5) * (0.1 + audioData.intensityControl * 1.2);
                }
                rippleMesh.geometry.attributes.position.needsUpdate = true;
                const hue = (audioData.beat * 0.5 + Date.now() / 4000) % 1;
                rippleMesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5);
                rippleMesh.material.emissiveIntensity = 0.2 + audioData.intensityControl * 0.8;
            }
        }

        // èºæ—‹
        function setupSpiral() {
            clearSceneObjects();
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.SphereGeometry(0.15, 8, 8);
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 12, 1, 0.6), emissive: new THREE.Color().setHSL(i / 12, 1, 0.3), emissiveIntensity: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = (i / 12) * Math.PI * 2;
                mesh.position.x = Math.cos(angle) * 1.2;
                mesh.position.y = Math.sin(angle) * 1.2;
                mesh.position.z = -0.5 + (i / 12);
                mesh.userData = { hueOffset: i / 12 };
                scene.add(mesh);
            }
            addImageToScene();
        }

        function updateSpiral(audioData) {
            const speedMult = audioData.speedControl || 0.6;
            scene.children.forEach((mesh) => {
                if (mesh instanceof THREE.Mesh && mesh !== imageMesh) {
                    mesh.rotation.x += audioData.high * 0.05 * speedMult * 2;
                    mesh.rotation.y += audioData.beat * 0.05 * speedMult * 2;
                    mesh.scale.setScalar(1 + audioData.intensityControl * 0.5);
                    const hue = (mesh.userData.hueOffset + Date.now() / 3000 + audioData.intensityControl * 0.5) % 1;
                    mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                    mesh.material.emissiveIntensity = 0.3 + audioData.intensityControl * 0.7;
                }
            });
        }

        // è»Œè·¡
        function setupTrail() {
            clearSceneObjects();
            for (let i = 0; i < 5; i++) {
                const geo = new THREE.TorusGeometry(0.5 + i * 0.3, 0.1, 16, 100);
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 5, 1, 0.6), emissive: new THREE.Color().setHSL(i / 5, 1, 0.3), emissiveIntensity: 0.7 });
                const mesh = new THREE.Mesh(geo, mat);
                scene.add(mesh);
            }
            addImageToScene();
        }

        function updateTrail(audioData) {
            const speedMult = audioData.speedControl || 0.6;
            scene.children.forEach((mesh, i) => {
                if (mesh instanceof THREE.Mesh && mesh !== imageMesh) {
                    mesh.rotation.z += audioData.beat * 0.05 * speedMult * 2;
                    mesh.scale.setScalar(1 + audioData.intensityControl * 0.6);
                    const hue = (i / 5 + Date.now() / 3000 + audioData.beat * audioData.frequencyControl * 0.3) % 1;
                    mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                    mesh.material.emissiveIntensity = 0.3 + audioData.intensityControl * 0.7;
                }
            });
        }

        // éš§é“
        function setupTunnel() {
            clearSceneObjects();
            for (let i = 0; i < 10; i++) {
                const geo = new THREE.TorusGeometry(1 + i * 0.5, 0.15, 32, 100);
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 10, 1, 0.6), emissive: new THREE.Color().setHSL(i / 10, 1, 0.3), emissiveIntensity: 0.7 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.z = -3 + i * 0.7;
                mesh.userData = { layer: i };
                scene.add(mesh);
            }
            addImageToScene();
        }

        function updateTunnel(audioData) {
            const speedMult = audioData.speedControl || 0.6;
            scene.children.forEach((mesh) => {
                if (mesh instanceof THREE.Mesh && mesh !== imageMesh) {
                    mesh.position.z += (0.08 + audioData.beat * 0.03) * speedMult * 1.5;
                    if (mesh.position.z > 1) {
                        mesh.position.z = -3 + mesh.userData.layer * 0.7;
                    }
                    mesh.scale.setScalar(1 + audioData.intensityControl * 0.4);
                    const hue = (mesh.userData.layer / 10 + Date.now() / 4000 + audioData.high * audioData.frequencyControl * 0.3) % 1;
                    mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                    mesh.material.emissiveIntensity = 0.3 + audioData.intensityControl * 0.7;
                }
            });
        }

        // Mandelbrot
        function updateMandelbrot(audioData) {
            ctx2D.fillStyle = '#ffffff';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = 0.3 + audioData.intensityControl * 2.5;
            const centerX = 0.5 + audioData.high * audioData.frequencyControl * 0.5;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const cr = (x / w - 0.5) / scale + centerX;
                    const ci = (y / h - 0.5) / scale + 0.5;

                    let real = cr, imag = ci;
                    let iter = 0;
                    for (let i = 0; i < 50; i++) {
                        const r2 = real * real, i2 = imag * imag;
                        if (r2 + i2 > 4) break;
                        const temp = r2 - i2 + cr;
                        imag = 2 * real * imag + ci;
                        real = temp;
                        iter++;
                    }
                    const hue = (iter / 50 + Date.now() / 5000 + audioData.frequencyControl * 0.5) % 1;
                    const rgb = hslToRgb(hue, audioData.frequencyControl, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // é›»æ¼¿
        function updatePlasma(audioData) {
            ctx2D.fillStyle = '#ffffff';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const speedMult = audioData.speedControl || 0.6;
            const time = Date.now() * 0.001 * speedMult * 1.5;
            const w = canvas2D.width;
            const h = canvas2D.height;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const v = Math.sin((x + time * 100) * 0.01) +
                             Math.sin((y + time * 50) * 0.01) +
                             Math.sin(Math.sqrt(x * x + y * y) * 0.01 + time * 50) * audioData.beat * audioData.intensityControl * 2;

                    const hue = (v * audioData.frequencyControl * 0.5 + audioData.high + Date.now() / 5000) % 1;
                    const rgb = hslToRgb(hue, audioData.frequencyControl, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // åœ–ç‰‡æ³¢å‹•
        function updateImageWave(audioData) {
            ctx2D.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            if (!uploadedImage) {
                ctx2D.fillStyle = '#999';
                ctx2D.font = '18px Arial';
                ctx2D.textAlign = 'center';
                ctx2D.fillText('è«‹ä¸Šå‚³åœ–ç‰‡', canvas2D.width / 2, canvas2D.height / 2);
                return;
            }

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = Math.min(w / uploadedImage.width, h / uploadedImage.height) * 0.85;
            const x = (w - uploadedImage.width * scale) / 2;
            const y = (h - uploadedImage.height * scale) / 2;

            ctx2D.globalAlpha = 0.85 + audioData.intensityControl * 0.15;
            ctx2D.drawImage(uploadedImage, x, y, uploadedImage.width * scale, uploadedImage.height * scale);
            ctx2D.globalAlpha = 1;

            const waveCount = 1 + Math.floor(audioData.intensityControl * 6);
            for (let waveIdx = 0; waveIdx < waveCount; waveIdx++) {
                const waveOffset = waveIdx * 0.4;
                ctx2D.strokeStyle = `hsl(${(audioData.beat * 360 + audioData.high * audioData.frequencyControl * 200 + waveIdx * 60) % 360}, ${audioData.frequencyControl * 100}%, ${60 + audioData.intensityControl * 20}%)`;
                ctx2D.lineWidth = 1 + audioData.beat * audioData.beatControl * 4;
                ctx2D.globalAlpha = 0.7 - waveIdx * 0.1;
                
                ctx2D.beginPath();
                const speedMult = audioData.speedControl || 0.6;
                for (let px = -50; px <= w + 50; px += 5) {
                    const py = h / 2 + Math.sin((px * 0.008 + Date.now() * 0.0008 * speedMult + waveOffset) * 8) * audioData.beat * audioData.intensityControl * 150;
                    px === -50 ? ctx2D.moveTo(px, py) : ctx2D.lineTo(px, py);
                }
                ctx2D.stroke();
            }
            ctx2D.globalAlpha = 1;
        }

        // HSL è½‰ RGB
        function hslToRgb(h, s, l) {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;

            let r = 0, g = 0, b = 0;
            if (h < 1/6) { r = c; g = x; }
            else if (h < 2/6) { r = x; g = c; }
            else if (h < 3/6) { g = c; b = x; }
            else if (h < 4/6) { g = x; b = c; }
            else if (h < 5/6) { r = x; b = c; }
            else { r = c; b = x; }

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        // â•â•â• é¢¨æ ¼åˆå§‹åŒ– â•â•â•
        const presetSetups = {
            neon: setupNeon, liquid: setupLiquid, geometric: setupGeometric, particle: setupParticle,
            spectrum: setupSpectrum, ripple: setupRipple, spiral: setupSpiral, trail: setupTrail, tunnel: setupTunnel
        };

        const presetUpdates = {
            neon: updateNeon, liquid: updateLiquid, geometric: updateGeometric, particle: updateParticle,
            spectrum: updateSpectrum, ripple: updateRipple, spiral: updateSpiral, trail: updateTrail, tunnel: updateTunnel,
            mandelbrot: updateMandelbrot, plasma: updatePlasma, imagewave: updateImageWave
        };

        function switchPreset(preset) {
            currentPreset = preset;
            document.querySelectorAll('.preset-btn').forEach(b => {
                b.classList.remove('active', 'bg-green-600', 'border-green-400', 'text-white');
                b.classList.add('bg-gray-300', 'border-transparent', 'text-gray-800');
            });
            event.target.classList.remove('bg-gray-300', 'border-transparent', 'text-gray-800');
            event.target.classList.add('active', 'bg-green-600', 'border-green-400', 'text-white');
            
            const is3D = !['mandelbrot', 'plasma', 'imagewave'].includes(preset);
            canvas3D.style.display = is3D ? 'block' : 'none';
            canvas2D.style.display = is3D ? 'none' : 'block';
            
            if (presetSetups[preset]) {
                presetSetups[preset]();
            }
        }

        // â•â•â• éŸ³æ¨‚ç›¸é—œå‡½æ•¸ â•â•â•
        function handleMusicSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            audioPlayer.src = url;
            document.getElementById('music-name').textContent = `âœ… å·²é¸æ“‡: ${file.name}`;
            document.getElementById('play-btn').textContent = 'â–¶ï¸ é–‹å§‹æ’­æ”¾';
            document.getElementById('play-btn').classList.remove('bg-gray-400', 'cursor-not-allowed');
            document.getElementById('play-btn').classList.add('bg-green-600', 'hover:bg-green-700');

            setupAudioAnalysis();
        }

        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    document.getElementById('image-name').textContent = `âœ… å·²é¸æ“‡: ${file.name}`;
                    addImageToScene();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function togglePlayback() {
            if (!audioPlayer.src) {
                alert('âŒ è«‹å…ˆé¸æ“‡éŸ³æ¨‚');
                return;
            }

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
            } else {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioPlayer.play();
                isPlaying = true;
            }
            updatePlayButtonState();
        }

        function updatePlayButtonState() {
            if (isPlaying) {
                document.getElementById('play-btn').textContent = 'â¸ï¸ æš«åœ';
                document.getElementById('play-btn').classList.remove('bg-green-600');
                document.getElementById('play-btn').classList.add('bg-red-600');
            } else {
                document.getElementById('play-btn').textContent = 'â–¶ï¸ é–‹å§‹æ’­æ”¾';
                document.getElementById('play-btn').classList.remove('bg-red-600');
                document.getElementById('play-btn').classList.add('bg-green-600');
            }
        }

        // â•â•â• äº‹ä»¶ç¶å®š â•â•â•
        document.getElementById('music-input').addEventListener('change', handleMusicSelect);
        document.getElementById('image-input').addEventListener('change', handleImageSelect);
        document.getElementById('play-btn').addEventListener('click', togglePlayback);

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => switchPreset(e.target.dataset.preset));
        });

        // â•â•â• å‹•ç•«å¾ªç’° â•â•â•
        function animate() {
            requestAnimationFrame(animate);

            // 3D åœ–ç‰‡æ—‹è½‰
            if (imageMesh && enable3DRotation && (isPlaying || rotationAxis !== 'none')) {
                const speedMult = (parseFloat(document.getElementById('range-speed').value) / 100) * 2 || 0.6;
                if (rotationAxis === 'x') {
                    imageMesh.rotation.x += rotationSpeed * 0.03 * speedMult;
                } else if (rotationAxis === 'y') {
                    imageMesh.rotation.y += rotationSpeed * 0.03 * speedMult;
                } else if (rotationAxis === 'z') {
                    imageMesh.rotation.z += rotationSpeed * 0.03 * speedMult;
                }
            }

            const audioData = getAudioData();

            if (presetUpdates[currentPreset]) {
                presetUpdates[currentPreset](audioData);
            }

            if (!['mandelbrot', 'plasma', 'imagewave'].includes(currentPreset)) {
                renderer.render(scene, camera);
            }
        }

        // â•â•â• åˆå§‹åŒ– â•â•â•
        window.addEventListener('load', () => {
            initThree();
            setupNeon();
            animate();
            updatePlayButtonState();
        });
    </script>
</body>
</html>
