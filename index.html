<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…±æ„Ÿå·¥ä½œå®¤ - Spotify ç‰ˆæœ¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #canvas-3d {
            display: block;
            width: 100%;
            height: 100%;
        }
        #canvas-2d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #4B5563;
            border-radius: 4px;
            width: 100%;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
        }
        .preset-btn.active {
            background: #1DB954 !important;
            border-color: #1ed760 !important;
        }
        .style-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen antialiased">

    <div id="app" class="flex h-screen overflow-hidden">

        <!-- å·¦å´æ§åˆ¶é¢æ¿ -->
        <div class="w-full lg:w-1/3 xl:w-1/4 p-6 flex flex-col space-y-3 bg-gray-800 border-r border-gray-700 overflow-y-auto">
            
            <header class="pb-3 border-b border-gray-700">
                <h1 class="text-2xl font-extrabold text-green-400">å…±æ„Ÿå·¥ä½œå®¤</h1>
                <p class="text-xs text-gray-400 mt-1">éŸ³æ¨‚ Ã— è—è¡“ Ã— è¦–è¦ºåŒ–</p>
            </header>

            <!-- æœ¬åœ°éŸ³æ¨‚ -->
            <div class="space-y-2">
                <h2 class="text-sm font-semibold text-gray-200">ğŸµ æœ¬åœ°éŸ³æ¨‚</h2>
                <input type="file" id="music-input" accept="audio/*" class="hidden" onchange="handleMusicSelect(event)">
                <label for="music-input" class="cursor-pointer block text-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg text-xs transition">
                    ğŸ“¤ ä¸Šå‚³éŸ³æ¨‚
                </label>
                <p id="music-name" class="text-xs text-gray-400">æœªé¸æ“‡</p>
                <audio id="audio-player"></audio>
            </div>

            <!-- åœ–ç‰‡ä¸Šå‚³ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-sm font-semibold text-gray-200">ğŸ–¼ï¸ èƒŒæ™¯åœ–ç‰‡</h2>
                <input type="file" id="image-input" accept="image/*" class="hidden" onchange="handleImageSelect(event)">
                <label for="image-input" class="cursor-pointer block text-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg text-xs transition">
                    ğŸ¨ ä¸Šå‚³åœ–ç‰‡
                </label>
                <img id="preview-image" class="hidden rounded-lg max-h-20 mx-auto">
                
                <!-- 3D æ—‹è½‰æ§åˆ¶ -->
                <div class="space-y-2 mt-2" id="rotation-section" style="display: none;">
                    <select id="rotation-axis" class="w-full px-3 py-2 bg-gray-700 text-white rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-yellow-400">
                        <option value="y">ğŸ”„ ç¹Yè»¸æ—‹è½‰ï¼ˆå·¦å³ç¿»è½‰ï¼‰</option>
                        <option value="x">ğŸ”„ ç¹Xè»¸æ—‹è½‰ï¼ˆä¸Šä¸‹ç¿»è½‰ï¼‰</option>
                        <option value="z">ğŸ”„ ç¹Zè»¸æ—‹è½‰ï¼ˆå¹³é¢æ—‹è½‰ï¼‰</option>
                    </select>
                    
                    <div class="control-group">
                        <label class="block text-xs font-medium text-gray-300">æ—‹è½‰é€Ÿåº¦</label>
                        <input type="range" min="0.1" max="5" step="0.1" value="1" id="rotation-speed" class="w-full">
                    </div>
                    
                    <label class="flex items-center space-x-2 text-xs">
                        <input type="checkbox" id="enable-3d-rotation" class="rounded" checked>
                        <span class="text-gray-300">æ’­æ”¾æ™‚è‡ªå‹•æ—‹è½‰</span>
                    </label>
                </div>
            </div>

            <!-- è¦–è¦ºé¢¨æ ¼ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-sm font-semibold text-gray-200">âœ¨ è¦–è¦ºé¢¨æ ¼</h2>
                <div class="style-grid text-xs">
                    <button class="preset-btn active bg-green-600 p-2 rounded-lg font-medium border-2 border-green-400" data-preset="neon">éœ“è™¹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="liquid">æ¶²æ…‹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="geometric">å¹¾ä½•</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="particle">ç²’å­</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="spectrum">é »è­œ</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="ripple">æ¼£æ¼ª</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="spiral">èºæ—‹</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="trail">è»Œè·¡</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="mandelbrot">åˆ†å½¢</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="plasma">é›»æ¼¿</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="tunnel">éš§é“</button>
                    <button class="preset-btn bg-gray-700 p-2 rounded-lg font-medium border-2 border-transparent hover:bg-gray-600" data-preset="imagewave">åœ–ç‰‡æ³¢</button>
                </div>
            </div>

            <!-- åƒæ•¸ -->
            <div class="space-y-2 pt-2 border-t border-gray-700">
                <h2 class="text-sm font-semibold text-gray-200">âš™ï¸ åƒæ•¸èª¿æ•´</h2>
                <p class="text-xs text-gray-400 italic">ğŸ’¡ è°ƒæ•´è¿™äº›åƒæ•¸æœƒæ”¹è®Šè¦–è¦ºæ•ˆæœå¼·åº¦å’Œé€Ÿåº¦</p>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">
                        ğŸ¯ ç¯€æ‹æ•æ„Ÿåº¦: <span id="beat-value">75</span>%
                    </label>
                    <input type="range" min="1" max="100" value="75" id="range-beat" 
                           oninput="document.getElementById('beat-value').textContent = this.value">
                    <p class="text-xs text-gray-500 mt-1">è¶Šé«˜ = è¦–è¦ºåŒ–åæ‡‰è¶Šå¼·</p>
                </div>

                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">
                        ğŸŒˆ é¡è‰²é£½å’Œåº¦: <span id="frequency-value">45</span>%
                    </label>
                    <input type="range" min="1" max="100" value="45" id="range-frequency"
                           oninput="document.getElementById('frequency-value').textContent = this.value">
                    <p class="text-xs text-gray-500 mt-1">è¶Šé«˜ = é¡è‰²è¶Šé®®è±”</p>
                </div>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">
                        ğŸ’¥ æ•ˆæœå¼·åº¦: <span id="intensity-value">90</span>%
                    </label>
                    <input type="range" min="1" max="100" value="90" id="range-intensity"
                           oninput="document.getElementById('intensity-value').textContent = this.value">
                    <p class="text-xs text-gray-500 mt-1">è¶Šé«˜ = æ•ˆæœè¶Šæ˜é¡¯</p>
                </div>
                
                <div class="control-group">
                    <label class="block text-xs font-medium text-gray-300">
                        âš¡ å‹•ç•«é€Ÿåº¦: <span id="speed-value">60</span>%
                    </label>
                    <input type="range" min="1" max="100" value="60" id="range-speed"
                           oninput="document.getElementById('speed-value').textContent = this.value">
                    <p class="text-xs text-gray-500 mt-1">è¶Šé«˜ = å‹•ç•«è¶Šå¿«</p>
                </div>
            </div>

            <!-- æ’­æ”¾ -->
            <div class="pt-2 border-t border-gray-700">
                <button id="play-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg text-sm transition">
                    â–¶ï¸ é–‹å§‹æ’­æ”¾
                </button>
            </div>
        </div>

        <!-- å³å´è¦–è¦ºè¼¸å‡º -->
        <div class="flex-1 relative bg-black overflow-hidden">
            <h2 class="absolute top-4 left-4 z-10 text-lg font-bold text-white bg-black bg-opacity-50 px-3 py-1 rounded">
                ğŸ¨ è¦–è¦ºè¼¸å‡º
            </h2>
            <canvas id="canvas-3d"></canvas>
            <canvas id="canvas-2d"></canvas>
        </div>
    </div>

    <script>
        // â•â•â• å…¨åŸŸè¨­å®š â•â•â•
        const canvas3D = document.getElementById('canvas-3d');
        const canvas2D = document.getElementById('canvas-2d');
        const ctx2D = canvas2D.getContext('2d');
        const audioPlayer = document.getElementById('audio-player');
        
        let scene, camera, renderer;
        let audioContext, analyser, dataArray;
        let isPlaying = false;
        let currentPreset = 'neon';
        let uploadedImage = null;
        let imageRotation = 0;
        let autoRotate = false;
        let autoRotateSpeed = 0.5;
        
        // 3D åœ–ç‰‡å°è±¡
        let imageMesh = null;
        let rotationAxis = 'y';
        let rotationSpeed = 1;
        let enable3DRotation = true;

        // â•â•â• äº‹ä»¶ç¶å®š â•â•â•
        document.getElementById('music-input').addEventListener('change', handleMusicSelect);
        document.getElementById('image-input').addEventListener('change', handleImageSelect);
        document.getElementById('play-btn').addEventListener('click', togglePlayback);

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => switchPreset(e.target.dataset.preset));
        });

        // â•â•â• éŸ³æ¨‚é¸æ“‡ â•â•â•
        function handleMusicSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                const file = files[0];
                document.getElementById('music-name').textContent = file.name;
                audioPlayer.src = URL.createObjectURL(file);
                setupAudioAnalysis();
            }
        }

        // â•â•â• åœ–ç‰‡é¸æ“‡ â•â•â•
        function handleImageSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage = img;
                        document.getElementById('preview-image').src = img.src;
                        document.getElementById('preview-image').classList.remove('hidden');
                        document.getElementById('rotation-section').style.display = 'block';
                        create3DImageMesh(img);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(files[0]);
            }
        }

        // â•â•â• å‰µå»º 3D åœ–ç‰‡ç¶²æ ¼ â•â•â•
        function create3DImageMesh(img) {
            // ç§»é™¤èˆŠçš„ç¶²æ ¼
            if (imageMesh) {
                scene.remove(imageMesh);
                imageMesh.geometry.dispose();
                imageMesh.material.dispose();
            }

            // å‰µå»ºç´‹ç†
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // ä½¿åœ–ç‰‡é©æ‡‰ç•«å¸ƒå°ºå¯¸
            const aspectRatio = img.width / img.height;
            if (aspectRatio > 1) {
                canvas.width = 1024;
                canvas.height = Math.floor(1024 / aspectRatio);
            } else {
                canvas.height = 1024;
                canvas.width = Math.floor(1024 * aspectRatio);
            }
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const texture = new THREE.CanvasTexture(canvas);
            
            // å‰µå»ºå¹³é¢å¹¾ä½•é«”
            const geometry = new THREE.PlaneGeometry(2, 2 * (canvas.height / canvas.width));
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                emissive: 0x404040,
                emissiveIntensity: 0.5
            });
            
            imageMesh = new THREE.Mesh(geometry, material);
            imageMesh.position.z = 0;
            scene.add(imageMesh);
        }

        // â•â•â• éŸ³è¨Šåˆ†æ â•â•â•
        function setupAudioAnalysis() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                const source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        function getAudioData() {
            // è®€å–åƒæ•¸å€¼
            const beatControl = parseFloat(document.getElementById('range-beat').value) / 100;
            const frequencyControl = parseFloat(document.getElementById('range-frequency').value) / 100;
            const intensityControl = parseFloat(document.getElementById('range-intensity').value) / 100;
            const speedControl = parseFloat(document.getElementById('range-speed').value) / 100;

            if (!analyser || !isPlaying) {
                return { 
                    beat: 0, mid: 0, high: 0, intensity: 0, data: new Uint8Array(128),
                    beatControl, frequencyControl, intensityControl, speedControl
                };
            }

            analyser.getByteFrequencyData(dataArray);
            let beat = 0, mid = 0, high = 0, intensity = 0;
            
            const lowEnd = Math.floor(dataArray.length * 0.15);
            const midEnd = Math.floor(dataArray.length * 0.4);
            
            for (let i = 0; i < lowEnd; i++) beat += dataArray[i];
            beat = (beat / lowEnd / 255) * beatControl;

            for (let i = lowEnd; i < midEnd; i++) mid += dataArray[i];
            mid = (mid / (midEnd - lowEnd) / 255) * beatControl;

            for (let i = midEnd; i < dataArray.length; i++) high += dataArray[i];
            high = (high / (dataArray.length - midEnd) / 255) * frequencyControl;

            for (let i = 0; i < dataArray.length; i++) intensity += dataArray[i];
            intensity = (intensity / dataArray.length / 255) * intensityControl;

            return { beat, mid, high, intensity, data: dataArray, beatControl, frequencyControl, intensityControl, speedControl };
        }

        // â•â•â• æ’­æ”¾æ§åˆ¶ â•â•â•
        function togglePlayback() {
            if (!audioPlayer.src) {
                document.getElementById('play-btn').textContent = "âŒ è«‹å…ˆä¸Šå‚³éŸ³æ¨‚";
                setTimeout(() => updatePlayButtonState(), 1500);
                return;
            }

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
            } else {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioPlayer.play();
                isPlaying = true;
            }
            updatePlayButtonState();
        }

        function updatePlayButtonState() {
            if (isPlaying) {
                document.getElementById('play-btn').textContent = 'â¸ï¸ æš«åœ';
                document.getElementById('play-btn').classList.remove('bg-green-600');
                document.getElementById('play-btn').classList.add('bg-red-600');
            } else {
                document.getElementById('play-btn').textContent = 'â–¶ï¸ é–‹å§‹æ’­æ”¾';
                document.getElementById('play-btn').classList.remove('bg-red-600');
                document.getElementById('play-btn').classList.add('bg-green-600');
            }
        }

        // â•â•â• Three.js åˆå§‹åŒ– â•â•â•
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(75, canvas3D.clientWidth / canvas3D.clientHeight, 0.1, 1000);
            camera.position.z = 2;

            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true, alpha: true });
            renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x1DB954, 1.5, 100);
            pointLight.position.set(0, 0, 3);
            scene.add(pointLight);

            window.addEventListener('resize', () => {
                const w = canvas3D.clientWidth;
                const h = canvas3D.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                canvas2D.width = w;
                canvas2D.height = h;
            });

            canvas2D.width = canvas3D.clientWidth;
            canvas2D.height = canvas3D.clientHeight;
        }

        // â•â•â• é¢¨æ ¼åˆå§‹åŒ– â•â•â•
        const presetSetups = {
            neon: setupNeon, liquid: setupLiquid, geometric: setupGeometric, particle: setupParticle,
            spectrum: setupSpectrum, ripple: setupRipple, spiral: setupSpiral, trail: setupTrail, tunnel: setupTunnel
        };

        const presetUpdates = {
            neon: updateNeon, liquid: updateLiquid, geometric: updateGeometric, particle: updateParticle,
            spectrum: updateSpectrum, ripple: updateRipple, spiral: updateSpiral, trail: updateTrail, tunnel: updateTunnel,
            mandelbrot: updateMandelbrot, plasma: updatePlasma, imagewave: updateImageWave
        };

        function switchPreset(preset) {
            currentPreset = preset;
            document.querySelectorAll('.preset-btn').forEach(b => {
                b.classList.remove('active', 'bg-green-600', 'border-green-400');
                b.classList.add('bg-gray-700', 'border-transparent');
            });
            event.target.classList.add('active', 'bg-green-600', 'border-green-400');
            
            const is3D = !['mandelbrot', 'plasma', 'imagewave'].includes(preset);
            canvas3D.style.display = is3D ? 'block' : 'none';
            canvas2D.style.display = is3D ? 'none' : 'block';
            
            if (presetSetups[preset]) {
                presetSetups[preset]();
                // å¦‚æœæœ‰ä¸Šå‚³åœ–ç‰‡ï¼Œé‡æ–°æ·»åŠ åˆ°å ´æ™¯
                if (imageMesh && is3D) {
                    scene.add(imageMesh);
                }
            }
        }

        // â•â•â• è¨­ç½® 3D æ—‹è½‰æ§åˆ¶ â•â•â•
        function setupRotationControls() {
            const rotationAxisSelect = document.getElementById('rotation-axis');
            const rotationSpeedSlider = document.getElementById('rotation-speed');
            const enable3DRotationCheckbox = document.getElementById('enable-3d-rotation');

            rotationAxisSelect.addEventListener('change', (e) => {
                rotationAxis = e.target.value;
            });

            rotationSpeedSlider.addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });

            enable3DRotationCheckbox.addEventListener('change', (e) => {
                enable3DRotation = e.target.checked;
            });
        }

        // â•â•â• æ‰€æœ‰è¦–è¦ºé¢¨æ ¼ â•â•â•
        
        // éœ“è™¹
        function setupNeon() {
            scene.clear();
            for (let i = 0; i < 8; i++) {
                const points = [];
                for (let x = -1; x <= 1; x += 0.05) {
                    points.push(new THREE.Vector3(x, Math.random() * 0.5, 0));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ color: 0x1DB954 });
                const line = new THREE.Line(geo, mat);
                line.position.y = -1 + i * 0.3;
                scene.add(line);
            }
        }
        function updateNeon(audioData) {
            const speedMultiplier = audioData.speedControl || 1;
            scene.children.forEach((line, i) => {
                const hue = (audioData.high + i * 0.1 + Date.now() / 10000) % 1;
                line.material.color.setHSL(hue, 1, 0.5 + audioData.intensity);
                if (Math.random() > 0.9 * (1 - audioData.beat * 0.5)) {
                    line.position.x = (Math.random() - 0.5) * 0.3 * audioData.beat;
                }
            });
        }

        // æ¶²æ…‹
        let liquidMesh;
        function setupLiquid() {
            scene.clear();
            const geo = new THREE.IcosahedronGeometry(1, 6);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, emissive: 0x0088ff, emissiveIntensity: 0.8
            });
            liquidMesh = new THREE.Mesh(geo, mat);
            scene.add(liquidMesh);
        }
        function updateLiquid(audioData) {
            if (liquidMesh) {
                const speedMult = audioData.speedControl || 1;
                liquidMesh.rotation.x += audioData.beat * 0.05 * speedMult;
                liquidMesh.rotation.y += audioData.mid * 0.05 * speedMult;
                liquidMesh.scale.setScalar(1.2 + audioData.beat * audioData.intensityControl * 0.5);
                const hue = (audioData.mid + Date.now() / 3000) % 1;
                liquidMesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5 + audioData.intensity);
                liquidMesh.material.emissiveIntensity = 0.5 + audioData.beat * audioData.intensityControl;
            }
        }

        // å¹¾ä½•
        function setupGeometric() {
            scene.clear();
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.OctahedronGeometry(0.3, 3);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 12, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 12, 1, 0.3),
                    emissiveIntensity: 0.8
                });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = i / 12 * Math.PI * 2;
                mesh.position.x = Math.cos(angle) * 1.5;
                mesh.position.y = Math.sin(angle) * 1.5;
                mesh.userData.angle = angle;
                mesh.userData.baseRadius = 1.5;
                mesh.userData.hueOffset = i / 12;
                scene.add(mesh);
            }
        }
        function updateGeometric(audioData) {
            const speedMult = audioData.speedControl || 1;
            scene.children.forEach((mesh, i) => {
                const radius = mesh.userData.baseRadius + audioData.beat * audioData.intensityControl * 0.8;
                mesh.position.x = Math.cos(mesh.userData.angle) * radius;
                mesh.position.y = Math.sin(mesh.userData.angle) * radius;
                mesh.rotation.x += audioData.high * 0.08 * speedMult;
                mesh.rotation.y += audioData.high * 0.08 * speedMult;
                const hue = (mesh.userData.hueOffset + audioData.high * audioData.frequencyControl * 0.5 + Date.now() / 4000) % 1;
                mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                mesh.material.emissiveIntensity = 0.6 + audioData.beat * audioData.intensityControl * 0.6;
            });
        }

        // ç²’å­
        let particleSystem;
        function setupParticle() {
            scene.clear();
            const count = 1500;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                pos[i * 3] = (Math.random() - 0.5) * 6;
                pos[i * 3 + 1] = (Math.random() - 0.5) * 6;
                pos[i * 3 + 2] = (Math.random() - 0.5) * 6;
                const hue = Math.random();
                const rgb = hslToRgb(hue, 1, 0.6);
                colors[i * 3] = rgb[0] / 255;
                colors[i * 3 + 1] = rgb[1] / 255;
                colors[i * 3 + 2] = rgb[2] / 255;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.04, vertexColors: true });
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
        }
        function updateParticle(audioData) {
            if (particleSystem) {
                const speedMult = audioData.speedControl || 1;
                const pos = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < pos.length; i += 3) {
                    pos[i] += (Math.random() - 0.5) * audioData.intensityControl * 0.2;
                    pos[i + 1] += (Math.random() - 0.5) * audioData.beat * 0.15;
                    if (Math.abs(pos[i]) > 3) pos[i] = (Math.random() - 0.5) * 6;
                    if (Math.abs(pos[i + 1]) > 3) pos[i + 1] = (Math.random() - 0.5) * 6;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.x += audioData.beat * 0.01 * speedMult;
                particleSystem.rotation.y += audioData.beat * 0.01 * speedMult;
            }
        }

        // é »è­œ
        function setupSpectrum() {
            scene.clear();
            for (let i = 0; i < 32; i++) {
                const geo = new THREE.BoxGeometry(0.08, 0.5, 0.08);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 32, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 32, 1, 0.35),
                    emissiveIntensity: 0.9
                });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = i / 32 * Math.PI * 2;
                mesh.position.x = Math.cos(angle) * 1.5;
                mesh.position.z = Math.sin(angle) * 1.5;
                mesh.userData.spectrumIndex = i;
                mesh.userData.hueOffset = i / 32;
                scene.add(mesh);
            }
        }
        function updateSpectrum(audioData) {
            scene.children.forEach((mesh) => {
                const idx = Math.floor(mesh.userData.spectrumIndex * audioData.data.length / 32);
                const val = audioData.data[idx] / 255;
                mesh.scale.y = 0.5 + val * audioData.intensityControl * 1.5;
                const hue = (mesh.userData.hueOffset + Date.now() / 5000) % 1;
                mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5 + val * 0.3);
                mesh.material.emissiveIntensity = 0.6 + val * audioData.intensityControl * 0.6;
            });
        }

        // æ¼£æ¼ª
        let rippleMesh;
        function setupRipple() {
            scene.clear();
            const geo = new THREE.PlaneGeometry(4, 4, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.6, wireframe: true
            });
            rippleMesh = new THREE.Mesh(geo, mat);
            rippleMesh.userData.originalPos = new Float32Array(geo.attributes.position.array);
            scene.add(rippleMesh);
        }
        function updateRipple(audioData) {
            if (rippleMesh) {
                const pos = rippleMesh.geometry.attributes.position.array;
                const orig = rippleMesh.userData.originalPos;
                const time = Date.now() * 0.001 * (audioData.speedControl || 1);
                
                for (let i = 2; i < pos.length; i += 3) {
                    const x = orig[i - 2];
                    const y = orig[i - 1];
                    const dist = Math.sqrt(x * x + y * y);
                    pos[i] = Math.sin(dist * 10 - time * 5) * (0.3 + audioData.beat * audioData.intensityControl * 0.8);
                }
                rippleMesh.geometry.attributes.position.needsUpdate = true;
                const hue = (audioData.beat * 0.5 + Date.now() / 4000) % 1;
                rippleMesh.material.color.setHSL(hue, audioData.frequencyControl, 0.5);
                rippleMesh.material.emissiveIntensity = 0.5 + audioData.intensityControl * 0.5;
            }
        }

        // èºæ—‹
        function setupSpiral() {
            scene.clear();
            for (let layer = 0; layer < 5; layer++) {
                const count = 20 + layer * 5;
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.15, 8, 8);
                    const hue = (layer / 5 + i / count) % 1;
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(hue, 1, 0.6),
                        emissive: new THREE.Color().setHSL(hue, 1, 0.35),
                        emissiveIntensity: 0.8
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = i / count * Math.PI * 2;
                    const radius = 0.5 + layer * 0.4;
                    mesh.position.x = Math.cos(angle) * radius;
                    mesh.position.y = Math.sin(angle) * radius;
                    mesh.position.z = (layer - 2) * 0.5;
                    mesh.userData.layer = layer;
                    mesh.userData.hueOffset = hue;
                    scene.add(mesh);
                }
            }
        }
        function updateSpiral(audioData) {
            const speedMult = audioData.speedControl || 1;
            scene.children.forEach((mesh) => {
                mesh.rotation.x += audioData.high * 0.05 * speedMult;
                mesh.rotation.y += audioData.beat * 0.05 * speedMult;
                mesh.scale.setScalar(1 + audioData.beat * audioData.intensityControl * 0.3);
                const hue = (mesh.userData.hueOffset + Date.now() / 3000 + audioData.intensityControl * 0.5) % 1;
                mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                mesh.material.emissiveIntensity = 0.6 + audioData.beat * audioData.intensityControl * 0.6;
            });
        }

        // è»Œè·¡
        function setupTrail() {
            scene.clear();
            for (let i = 0; i < 5; i++) {
                const curve = new THREE.LineCurve3(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0));
                const geo = new THREE.TubeGeometry(curve, 20, 0.1, 8);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(i / 5, 1, 0.6),
                    emissive: new THREE.Color().setHSL(i / 5, 1, 0.35),
                    emissiveIntensity: 0.9
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.z = i / 5 * Math.PI * 2;
                mesh.userData.index = i;
                scene.add(mesh);
            }
        }
        function updateTrail(audioData) {
            const speedMult = audioData.speedControl || 1;
            scene.children.forEach((mesh, i) => {
                mesh.rotation.z += audioData.beat * 0.05 * speedMult;
                mesh.scale.setScalar(1 + audioData.beat * audioData.intensityControl * 0.4);
                const hue = (i / 5 + Date.now() / 3000 + audioData.beat * audioData.frequencyControl * 0.3) % 1;
                mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                mesh.material.emissiveIntensity = 0.7 + audioData.intensityControl * audioData.intensityControl * 0.5;
            });
        }

        // éš§é“
        function setupTunnel() {
            scene.clear();
            for (let layer = 0; layer < 10; layer++) {
                const count = 16;
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.1, 8, 8);
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(layer / 10 + i / count, 1, 0.6),
                        emissive: new THREE.Color().setHSL(layer / 10 + i / count, 1, 0.35),
                        emissiveIntensity: 0.9
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = i / count * Math.PI * 2;
                    const radius = 0.3 + layer * 0.25;
                    mesh.position.x = Math.cos(angle) * radius;
                    mesh.position.y = Math.sin(angle) * radius;
                    mesh.position.z = -3 + layer * 0.7;
                    mesh.userData.layer = layer;
                    scene.add(mesh);
                }
            }
        }
        function updateTunnel(audioData) {
            const speedMult = audioData.speedControl || 1;
            scene.children.forEach((mesh) => {
                mesh.position.z += (0.08 + audioData.beat * 0.05) * speedMult;
                if (mesh.position.z > 1) {
                    mesh.position.z = -3 + mesh.userData.layer * 0.7;
                }
                mesh.scale.setScalar(1 + audioData.beat * 0.4 + audioData.intensityControl * 0.2);
                const hue = (mesh.userData.layer / 10 + Date.now() / 4000 + audioData.high * audioData.frequencyControl * 0.3) % 1;
                mesh.material.color.setHSL(hue, audioData.frequencyControl, 0.6);
                mesh.material.emissiveIntensity = 0.7 + audioData.intensityControl * 0.5;
            });
        }

        // Mandelbrot
        function updateMandelbrot(audioData) {
            ctx2D.fillStyle = '#0a0a0a';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = 0.5 + audioData.intensityControl * 2;
            const centerX = 0.5 + audioData.high * audioData.frequencyControl * 0.3;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const cr = (x / w - 0.5) / scale + centerX;
                    const ci = (y / h - 0.5) / scale + 0.5;

                    let real = cr, imag = ci;
                    let iter = 0;
                    for (let i = 0; i < 50; i++) {
                        const r2 = real * real, i2 = imag * imag;
                        if (r2 + i2 > 4) break;
                        const temp = r2 - i2 + cr;
                        imag = 2 * real * imag + ci;
                        real = temp;
                        iter++;
                    }
                    const hue = (iter / 50 + Date.now() / 5000 + audioData.frequencyControl * 0.5) % 1;
                    const rgb = hslToRgb(hue, audioData.frequencyControl, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // é›»æ¼¿
        function updatePlasma(audioData) {
            ctx2D.fillStyle = '#0a0a0a';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            const time = Date.now() * 0.001 * (audioData.speedControl || 1);
            const w = canvas2D.width;
            const h = canvas2D.height;

            for (let x = 0; x < w; x += 4) {
                for (let y = 0; y < h; y += 4) {
                    const v = Math.sin((x + time * 100) * 0.01) +
                             Math.sin((y + time * 50) * 0.01) +
                             Math.sin(Math.sqrt(x * x + y * y) * 0.01 + time * 50) * audioData.beat * audioData.intensityControl;

                    const hue = (v * audioData.frequencyControl * 0.3 + audioData.high + Date.now() / 5000) % 1;
                    const rgb = hslToRgb(hue, audioData.frequencyControl, 0.5);
                    ctx2D.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    ctx2D.fillRect(x, y, 4, 4);
                }
            }
        }

        // åœ–ç‰‡æ³¢å‹•
        function updateImageWave(audioData) {
            ctx2D.fillStyle = 'rgba(10, 10, 10, 0.2)';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

            if (!uploadedImage) {
                ctx2D.fillStyle = '#666';
                ctx2D.font = '18px Arial';
                ctx2D.textAlign = 'center';
                ctx2D.fillText('è«‹ä¸Šå‚³åœ–ç‰‡', canvas2D.width / 2, canvas2D.height / 2);
                return;
            }

            const w = canvas2D.width;
            const h = canvas2D.height;
            const scale = Math.min(w / uploadedImage.width, h / uploadedImage.height) * 0.85;
            const x = (w - uploadedImage.width * scale) / 2;
            const y = (h - uploadedImage.height * scale) / 2;

            ctx2D.globalAlpha = 0.9 + audioData.intensityControl * 0.1;
            ctx2D.drawImage(uploadedImage, x, y, uploadedImage.width * scale, uploadedImage.height * scale);
            ctx2D.globalAlpha = 1;

            const waveCount = 2 + Math.floor(audioData.intensityControl * 4);
            for (let waveIdx = 0; waveIdx < waveCount; waveIdx++) {
                const waveOffset = waveIdx * 0.4;
                ctx2D.strokeStyle = `hsl(${(audioData.beat * 360 + audioData.high * audioData.frequencyControl * 180 + waveIdx * 60) % 360}, ${audioData.frequencyControl * 100}%, ${60 + audioData.intensityControl * 20}%)`;
                ctx2D.lineWidth = 1 + audioData.beat * 3;
                ctx2D.globalAlpha = 0.7 - waveIdx * 0.15;
                
                ctx2D.beginPath();
                for (let px = -50; px <= w + 50; px += 5) {
                    const py = h / 2 + Math.sin((px * 0.008 + Date.now() * 0.0008 + waveOffset) * 8) * audioData.beat * audioData.intensityControl * 120;
                    px === -50 ? ctx2D.moveTo(px, py) : ctx2D.lineTo(px, py);
                }
                ctx2D.stroke();
            }
            ctx2D.globalAlpha = 1;
        }

        // â•â•â• è‰²å½©è½‰æ› â•â•â•
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // â•â•â• å‹•ç•«å¾ªç’° â•â•â•
        function animate() {
            requestAnimationFrame(animate);

            // 3D åœ–ç‰‡æ—‹è½‰
            if (imageMesh && enable3DRotation && isPlaying) {
                const speedMult = (parseFloat(document.getElementById('range-speed').value) / 100) || 1;
                if (rotationAxis === 'x') {
                    imageMesh.rotation.x += rotationSpeed * 0.03 * speedMult;
                } else if (rotationAxis === 'y') {
                    imageMesh.rotation.y += rotationSpeed * 0.03 * speedMult;
                } else if (rotationAxis === 'z') {
                    imageMesh.rotation.z += rotationSpeed * 0.03 * speedMult;
                }
            }

            const audioData = getAudioData();

            if (presetUpdates[currentPreset]) {
                presetUpdates[currentPreset](audioData);
            }

            if (!['mandelbrot', 'plasma', 'imagewave'].includes(currentPreset)) {
                renderer.render(scene, camera);
            }
        }

        // â•â•â• åˆå§‹åŒ– â•â•â•
        window.addEventListener('load', () => {
            initThree();
            setupNeon();
            updateSceneWithImage();
            setupRotationControls();
            animate();
            updatePlayButtonState();
        });
    </script>
</body>
</html>
